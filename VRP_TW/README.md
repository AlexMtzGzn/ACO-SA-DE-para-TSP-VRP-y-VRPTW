# üöö Resoluci√≥n del VRPTW con ACO optimizado por DE

Este proyecto implementa una soluci√≥n h√≠brida para el Problema de Rutas de Veh√≠culos con Ventanas de Tiempo (VRPTW), utilizando el algoritmo Ant Colony Optimization (ACO) optimizado autom√°ticamente mediante el Algoritmo Evolutivo Diferencial (DE).

## üß© ¬øQu√© es el VRPTW?

El Problema de Rutas de Veh√≠culos con Ventanas de Tiempo (VRPTW, por sus siglas en ingl√©s "Vehicle Routing Problem with Time Windows") es una extensi√≥n del Problema de Rutas de Veh√≠culos (VRP) cl√°sico que a√±ade restricciones temporales.

Consiste en encontrar las rutas √≥ptimas para una flota de veh√≠culos que deben visitar un conjunto de clientes dentro de intervalos de tiempo espec√≠ficos (ventanas de tiempo), considerando tambi√©n restricciones de capacidad de carga y la demanda de cada cliente, con el objetivo de minimizar la distancia total recorrida.

## üïí Restricciones de Ventanas de Tiempo

Cada cliente debe ser visitado dentro de una ventana de tiempo espec√≠fica:
- **Tiempo m√°s temprano** (earliest time): El veh√≠culo no puede comenzar el servicio antes de este tiempo.
- **Tiempo m√°s tard√≠o** (latest time): El veh√≠culo debe comenzar el servicio a m√°s tardar en este tiempo.

Si un veh√≠culo llega antes del tiempo m√°s temprano, debe esperar. Si no puede llegar antes del tiempo m√°s tard√≠o, la soluci√≥n no es factible.

## üêú ¬øQu√© es ACO (Ant Colony Optimization)?

ACO (Ant Colony Optimization) es una metaheur√≠stica inspirada en el comportamiento colectivo de las colonias de hormigas.

En la naturaleza, las hormigas encuentran caminos cortos entre su nido y las fuentes de comida dejando feromonas. Cuanto mejor sea el camino (m√°s corto), m√°s feromonas se acumulan, y m√°s probable es que otras hormigas lo sigan, reforzando as√≠ la soluci√≥n.

En el VRPTW, simulamos este comportamiento:

- Cada "hormiga" construye una soluci√≥n recorriendo clientes.
- Las decisiones se toman con base en:
  - **Cantidad de feromona** (lo aprendido)
  - **Visibilidad** (inverso de la distancia)
  - **Factibilidad temporal** (ventanas de tiempo)
- Despu√©s de cada iteraci√≥n, se actualizan las feromonas, favoreciendo los caminos m√°s cortos y temporalmente viables.
- Se respetan las **restricciones de capacidad y tiempo** de cada veh√≠culo.

## üß¨ ¬øQu√© es el Algoritmo Evolutivo Diferencial (DE)?

DE es una t√©cnica de optimizaci√≥n basada en poblaciones. Ideal para problemas continuos y para ajustar par√°metros autom√°ticamente.

üìå Se basa en tres operadores:

Mutaci√≥n ‚Äì Combinaci√≥n de soluciones existentes.

Cruzamiento (recombinaci√≥n) ‚Äì Mezcla de individuo mutado y original.

Selecci√≥n ‚Äì Se elige el m√°s apto entre ambos.

## üß† ¬øC√≥mo se resolvi√≥ el VRPTW?

El enfoque fue **h√≠brido**:

- **ACO** resuelve el VRPTW directamente, respetando las restricciones de capacidad y tiempo.
- **DE** encuentra los mejores par√°metros para ACO.
- **Selecci√≥n Greedy** de veh√≠culos cuando se alcanza la capacidad m√°xima o cuando no es posible cumplir con las ventanas de tiempo.

üéØ **Par√°metros optimizados por DE**:
El algoritmo Evolutivo Diferencial (DE) se utiliz√≥ para calibrar los par√°metros del algoritmo ACO. Los siguientes rangos fueron considerados para cada par√°metro:

- **Œ± (alpha)**: Influencia de la feromona. Ajustado entre **1.0 y 2.5**.
- **Œ≤ (beta)**: Influencia de la visibilidad (heur√≠stica). Ajustado entre **1.0 y 2.5**.
- **Œ≥ (gamma)**: Influencia de la factibilidad temporal. Ajustado entre **1.0 y 2.5**.
- **œÅ (rho)**: Tasa de evaporaci√≥n de feromonas. Ajustado entre **0.1 y 0.9**.
- **N√∫mero de hormigas**: Ajustado entre **20 y 100**.
- **N√∫mero de iteraciones**: Ajustado entre **50 y 200**.

### üìä ¬øC√≥mo se generaron los par√°metros?

Durante la ejecuci√≥n de DE, cada par√°metro fue generado aleatoriamente dentro de los siguientes intervalos:

- **Œ± (alpha)**: Se gener√≥ entre **1.0 y 2.5**.
- **Œ≤ (beta)**: Se gener√≥ entre **1.0 y 2.5**.
- **Œ≥ (gamma)**: Se gener√≥ entre **1.0 y 2.5**.
- **œÅ (rho)**: Se gener√≥ entre **0.1 y 0.9**.
- **N√∫mero de hormigas**: Se gener√≥ entre **20 y 100**.
- **N√∫mero de iteraciones**: Se gener√≥ entre **50 y 200**.

Esto permiti√≥ ajustar de manera eficiente los par√°metros para obtener la mejor soluci√≥n en el VRPTW sin necesidad de hacerlo manualmente.

üîÅ **Proceso combinado**:

1. DE genera una poblaci√≥n de par√°metros.
2. Cada conjunto se eval√∫a ejecutando ACO.
3. Se obtiene la distancia total de todas las rutas generadas y el n√∫mero de veh√≠culos utilizados.
4. DE evoluciona los par√°metros para minimizar la distancia total y el n√∫mero de veh√≠culos.

üìà As√≠ se optimiza el rendimiento de ACO **sin ajustar nada manualmente**.

## üöõ Gesti√≥n de Veh√≠culos, Capacidad y Tiempo

La principal diferencia con respecto al VRP cl√°sico es la incorporaci√≥n de:

- **Restricciones de capacidad**: Cada veh√≠culo tiene una capacidad m√°xima.
- **Demanda de clientes**: Cada cliente requiere cierta cantidad de producto.
- **Ventanas de tiempo**: Cada cliente debe ser visitado dentro de un intervalo de tiempo espec√≠fico.
- **Tiempo de servicio**: Cada cliente requiere un tiempo de servicio determinado.
- **Tiempos de viaje**: El tiempo necesario para viajar entre localizaciones.
- **Selecci√≥n greedy de veh√≠culos**: Cuando un veh√≠culo alcanza su capacidad m√°xima o no puede cumplir con las ventanas de tiempo restantes, se selecciona el siguiente veh√≠culo disponible.

El algoritmo construye las rutas considerando estas restricciones:

1. Comienza desde el dep√≥sito con tiempo inicial 0.
2. Selecciona el siguiente cliente bas√°ndose en feromonas, visibilidad y factibilidad temporal.
3. Verifica si la capacidad del veh√≠culo permite atender al cliente.
4. Verifica si el veh√≠culo puede llegar dentro de la ventana de tiempo del cliente.
5. Actualiza el tiempo de llegada y espera si es necesario.
6. Si no es posible atender al cliente, regresa al dep√≥sito y utiliza el siguiente veh√≠culo.
7. Contin√∫a hasta que todos los clientes sean atendidos.

## üéØ Resultados Esperados

El objetivo principal de este proyecto es encontrar las mejores rutas para el **Problema de Rutas de Veh√≠culos con Ventanas de Tiempo (VRPTW)** mediante el uso combinado del algoritmo **ACO** y el algoritmo **DE** para optimizar los par√°metros.

### üîç ¬øQu√© se espera como salida?

1. **Las mejores rutas encontradas**: Las rutas √≥ptimas para cada veh√≠culo, que minimizan la distancia total recorrida y cumplen con todas las restricciones.
2. **Tiempo de ejecuci√≥n total**: El tiempo total que tom√≥ ejecutar el proceso de optimizaci√≥n y encontrar las mejores rutas.
3. **Utilizaci√≥n de veh√≠culos**: Cantidad de veh√≠culos utilizados y su nivel de ocupaci√≥n.
4. **Planificaci√≥n temporal**: Tiempos de llegada, espera y salida para cada cliente.

### üì¶ Resultados Generados

3. **Archivo JSON**

   - Se genera un archivo `.json` que contiene todos los par√°metros utilizados en la ejecuci√≥n, tales como:
     - Nombre del archivo de entrada
     - Tiempo de ejecuci√≥n en minutos
     - Œ± (alpha), Œ≤ (beta), Œ≥ (gamma), œÅ (rho)
     - N√∫mero de hormigas
     - N√∫mero de iteraciones
     - Valor de fitness de la soluci√≥n
     - Rutas generadas para cada veh√≠culo (listas de clientes)
     - Capacidad utilizada por cada veh√≠culo
     - Tiempos de llegada y salida para cada cliente

4. **Imagen simulada**

   - Se genera una imagen est√°tica (`.png`) que representa visualmente las **rutas generadas** por el algoritmo ACO.
   - Las rutas de diferentes veh√≠culos se representan con colores distintos.
   - Incluye informaci√≥n sobre las ventanas de tiempo de cada cliente.

   Ejemplo de visualizaci√≥n:
   ![Imagen Ruta](Recursos_Readme/Ejemplo_png.png)

5. **GIF simulado**

   - Se crea un **GIF animado** que simula el proceso de construcci√≥n de las rutas en el tiempo, mostrando c√≥mo los veh√≠culos recorren los clientes respetando las ventanas de tiempo.

   Ejemplo de animaci√≥n:
   ![Simulador Ruta](Recursos_Readme/Ejemplo_gif.gif)

### üíæ Ejemplo de archivo JSON

El archivo `JSON` generado tendr√° la siguiente estructura:
```json
{
  "Archivo": "C101_(25)",
  "Tiempo Ejecucion en Minutos": 145,
  "Alpha": 2.15387500407114,
  "Beta": 2.3205640269399451,
  "Gamma": 1.85674044189823,
  "Rho": 0.675674044189823,
  "Numero Hormigas": 32,
  "Numero Iteraciones": 124,
  "Fitness Global": 191.27069377207884,
  "Numero de Vehiculos": 3,
  "Rutas Vehiculos": [
    {
      "Vehiculo": 1,
      "Capacidad": 200,
      "Carga": 192,
      "Ruta": [0, 5, 3, 7, 8, 10, 11, 0],
      "Tiempos": [
        {"Cliente": 0, "Llegada": 0, "Inicio_Servicio": 0, "Fin_Servicio": 0, "Tiempo_Espera": 0},
        {"Cliente": 5, "Llegada": 15, "Inicio_Servicio": 30, "Fin_Servicio": 40, "Tiempo_Espera": 15},
        {"Cliente": 3, "Llegada": 52, "Inicio_Servicio": 52, "Fin_Servicio": 62, "Tiempo_Espera": 0},
        {"Cliente": 7, "Llegada": 79, "Inicio_Servicio": 79, "Fin_Servicio": 89, "Tiempo_Espera": 0},
        {"Cliente": 8, "Llegada": 104, "Inicio_Servicio": 104, "Fin_Servicio": 114, "Tiempo_Espera": 0},
        {"Cliente": 10, "Llegada": 132, "Inicio_Servicio": 132, "Fin_Servicio": 142, "Tiempo_Espera": 0},
        {"Cliente": 11, "Llegada": 157, "Inicio_Servicio": 157, "Fin_Servicio": 167, "Tiempo_Espera": 0},
        {"Cliente": 0, "Llegada": 189, "Inicio_Servicio": 189, "Fin_Servicio": 189, "Tiempo_Espera": 0}
      ]
    },
    {
      "Vehiculo": 2,
      "Capacidad": 200,
      "Carga": 187,
      "Ruta": [0, 14, 16, 15, 19, 18, 17, 13, 0],
      "Tiempos": [
        {"Cliente": 0, "Llegada": 0, "Inicio_Servicio": 0, "Fin_Servicio": 0, "Tiempo_Espera": 0},
        {"Cliente": 14, "Llegada": 25, "Inicio_Servicio": 45, "Fin_Servicio": 55, "Tiempo_Espera": 20},
        {"Cliente": 16, "Llegada": 67, "Inicio_Servicio": 67, "Fin_Servicio": 77, "Tiempo_Espera": 0},
        {"Cliente": 15, "Llegada": 92, "Inicio_Servicio": 92, "Fin_Servicio": 102, "Tiempo_Espera": 0},
        {"Cliente": 19, "Llegada": 117, "Inicio_Servicio": 129, "Fin_Servicio": 139, "Tiempo_Espera": 12},
        {"Cliente": 18, "Llegada": 152, "Inicio_Servicio": 152, "Fin_Servicio": 162, "Tiempo_Espera": 0},
        {"Cliente": 17, "Llegada": 175, "Inicio_Servicio": 175, "Fin_Servicio": 185, "Tiempo_Espera": 0},
        {"Cliente": 13, "Llegada": 198, "Inicio_Servicio": 198, "Fin_Servicio": 208, "Tiempo_Espera": 0},
        {"Cliente": 0, "Llegada": 232, "Inicio_Servicio": 232, "Fin_Servicio": 232, "Tiempo_Espera": 0}
      ]
    },
    {
      "Vehiculo": 3,
      "Capacidad": 200,
      "Carga": 195,
      "Ruta": [0, 21, 22, 23, 24, 25, 20, 0],
      "Tiempos": [
        {"Cliente": 0, "Llegada": 0, "Inicio_Servicio": 0, "Fin_Servicio": 0, "Tiempo_Espera": 0},
        {"Cliente": 21, "Llegada": 18, "Inicio_Servicio": 35, "Fin_Servicio": 45, "Tiempo_Espera": 17},
        {"Cliente": 22, "Llegada": 62, "Inicio_Servicio": 62, "Fin_Servicio": 72, "Tiempo_Espera": 0},
        {"Cliente": 23, "Llegada": 89, "Inicio_Servicio": 89, "Fin_Servicio": 99, "Tiempo_Espera": 0},
        {"Cliente": 24, "Llegada": 114, "Inicio_Servicio": 114, "Fin_Servicio": 124, "Tiempo_Espera": 0},
        {"Cliente": 25, "Llegada": 141, "Inicio_Servicio": 141, "Fin_Servicio": 151, "Tiempo_Espera": 0},
        {"Cliente": 20, "Llegada": 173, "Inicio_Servicio": 173, "Fin_Servicio": 183, "Tiempo_Espera": 0},
        {"Cliente": 0, "Llegada": 212, "Inicio_Servicio": 212, "Fin_Servicio": 212, "Tiempo_Espera": 0}
      ]
    }
  ]
}
```

## Requisitos

Para ejecutar este proyecto, aseg√∫rate de tener lo siguiente:

### üßë‚Äçüíª C Compiler

Es necesario tener un compilador de C instalado (como gcc) para compilar el c√≥digo fuente.

### Librer√≠a `cJSON`:  
  Este proyecto requiere la librer√≠a `cJSON` para trabajar con archivos JSON en C.  
  Puedes encontrarla y consultar c√≥mo instalarla en su repositorio oficial:
    
  üëâ [https://github.com/DaveGamble/cJSON](https://github.com/DaveGamble/cJSON)

### üì¶ Python

Aseg√∫rate de tener Python instalado junto con las siguientes bibliotecas:

- json
- os
- sys
- matplotlib
- numpy

## Compilaci√≥n y Ejecuci√≥n

### 1. **Compilaci√≥n**

Para compilar el proyecto, usa el siguiente comando:

```bash
make
```

Este comando compilar√° el c√≥digo en modo release por defecto (optimizado). Si prefieres compilar en modo debug para facilitar la depuraci√≥n, puedes usar:

```bash
make debug
```

### 2. Ejecutar el Programa

Una vez compilado el proyecto, puedes ejecutar el ejecutable generado (llamado main) con los siguientes par√°metros:

```bash
./main <poblacion> <generaciones> <archivo> <numero_de_clientes> <capacidad_vehiculo>
```

Ejemplo:
```bash
./main 50 100 C101 25 200
```

- poblacion: el tama√±o de la poblaci√≥n para el algoritmo.
- generaciones: el n√∫mero de generaciones que el algoritmo debe ejecutar.
- archivo: el archivo de entrada.
- numero_de_clientes: el n√∫mero de clientes a considerar en el VRPTW.
- capacidad_vehiculo: la capacidad m√°xima de cada veh√≠culo.

### 3. Limpieza

Si deseas limpiar los archivos generados (archivos objeto, ejecutables, etc.), puedes usar:

```bash
make clean
```

## üìÅ Estructura del Proyecto

```bash
.
‚îú‚îÄ‚îÄ build/                     # Archivos objetos y dependencias generados por el compilador
‚îú‚îÄ‚îÄ include/                  # Archivos de cabecera (.h)
‚îÇ   ‚îú‚îÄ‚îÄ aed.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_vrptw.h  # Modificado para VRPTW
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.h
‚îÇ   ‚îú‚îÄ‚îÄ estructuras.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.h
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.h
‚îÇ   ‚îî‚îÄ‚îÄ vrptw_aco.h            # Modificado para VRPTW
‚îú‚îÄ‚îÄ Instancias/               # Instancias CSV utilizadas en la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_25/        
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_50/
‚îÇ   ‚îî‚îÄ‚îÄ Instancias_100/
‚îú‚îÄ‚îÄ main                      # Ejecutable generado tras compilar
‚îú‚îÄ‚îÄ makefile                  # Makefile para compilar el proyecto
‚îú‚îÄ‚îÄ README.md                 # Archivo de documentaci√≥n
‚îú‚îÄ‚îÄ Resultados/               # Salidas generadas por la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_25/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_50/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îî‚îÄ‚îÄ Resultados_100/
‚îÇ       ‚îú‚îÄ‚îÄ Gifs/
‚îÇ       ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ       ‚îî‚îÄ‚îÄ Json/
‚îú‚îÄ‚îÄ src/                      # C√≥digo fuente del proyecto en C y Python
‚îÇ   ‚îú‚îÄ‚îÄ aed.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_vrptw.c  # Modificado para VRPTW
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.c
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.c
‚îÇ   ‚îú‚îÄ‚îÄ vrptw_aco.c           # Modificado para VRPTW
‚îÇ   ‚îî‚îÄ‚îÄ Simulador_VRPTW/      # Modificado para VRPTW
‚îÇ       ‚îî‚îÄ‚îÄ simulador_vrptw.py
‚îî‚îÄ‚îÄ VRP_Solomon/              # Instancias del benchmark Solomon para VRPTW
    ‚îú‚îÄ‚îÄ VRP_Solomon_25/
    ‚îÇ   ‚îú‚îÄ‚îÄ C101_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C201_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R101_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R201_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC101_(25).txt
    ‚îÇ   ‚îî‚îÄ‚îÄ RC201_(25).txt
    ‚îú‚îÄ‚îÄ VRP_Solomon_50/
    ‚îÇ   ‚îú‚îÄ‚îÄ C101_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C201_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R101_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R201_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC101_(50).txt
    ‚îÇ   ‚îî‚îÄ‚îÄ RC201_(50).txt
    ‚îî‚îÄ‚îÄ VRP_Solomon_100/
        ‚îú‚îÄ‚îÄ C101_(100).txt
        ‚îú‚îÄ‚îÄ C201_(100).txt
        ‚îú‚îÄ‚îÄ R101_(100).txt
        ‚îú‚îÄ‚îÄ R201_(100).txt
        ‚îî‚îÄ‚îÄ RC101_(100).txt
```

### ‚úÖ Consideraciones finales

Este trabajo busca contribuir al estudio y soluci√≥n del problema VRPTW mediante la implementaci√≥n de algoritmos bioinspirados. La principal diferencia respecto a la versi√≥n VRP cl√°sica es la incorporaci√≥n de restricciones de ventanas de tiempo, lo que a√±ade una capa de complejidad al problema y requiere una gesti√≥n temporal durante la construcci√≥n de las rutas. Se invita a la comunidad a explorar, reutilizar y mejorar el c√≥digo seg√∫n sus necesidades.

## üë• Contribuciones

- üßë‚Äçüè´ **Dr. Edwin Montes Orozco**  
  Director de PT y responsable del acompa√±amiento acad√©mico durante el desarrollo del proyecto.

- üë®‚Äçüíª **Alejandro Mart√≠nez Guzm√°n**  
  Autor del proyecto. Encargado del dise√±o, implementaci√≥n y documentaci√≥n del sistema de optimizaci√≥n.

- üß™ **Jaime L√≥pez Lara**  
  Ayudante en la ejecuci√≥n del c√≥digo y recolecci√≥n de resultados.

## üìù Licencia

Este proyecto est√° licenciado bajo los t√©rminos de la licencia MIT.  
Consulta el archivo [LICENSE](./LICENSE) para m√°s detalles.