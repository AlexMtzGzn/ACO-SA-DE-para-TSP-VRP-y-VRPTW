# üöö Resoluci√≥n del VRPTW con ACO optimizado por DE

Este proyecto implementa una soluci√≥n h√≠brida para el Problema de Rutas de Veh√≠culos con Ventanas de Tiempo (VRPTW), utilizando el algoritmo Ant Colony Optimization (ACO) optimizado autom√°ticamente mediante el Algoritmo Evolutivo Diferencial (DE).

## üß© ¬øQu√© es el VRPTW?

El Problema de Rutas de Veh√≠culos con Ventanas de Tiempo (VRPTW, por sus siglas en ingl√©s "Vehicle Routing Problem with Time Windows") es una extensi√≥n del Problema de Rutas de Veh√≠culos (VRP) cl√°sico que a√±ade restricciones temporales.

Consiste en encontrar las rutas √≥ptimas para una flota de veh√≠culos que deben visitar un conjunto de clientes dentro de intervalos de tiempo espec√≠ficos (ventanas de tiempo), considerando tambi√©n restricciones de capacidad de carga y la demanda de cada cliente, con el objetivo de minimizar la distancia total recorrida.

## üïí Restricciones de Ventanas de Tiempo

Cada cliente debe ser visitado dentro de una ventana de tiempo espec√≠fica:

- **Tiempo m√°s temprano** (earliest time): El veh√≠culo no puede comenzar el servicio antes de este tiempo.
- **Tiempo m√°s tard√≠o** (latest time): El veh√≠culo debe comenzar el servicio a m√°s tardar en este tiempo.

Si un veh√≠culo llega antes del tiempo m√°s temprano, debe esperar. Si no puede llegar antes del tiempo m√°s tard√≠o, la soluci√≥n no es factible.

## üêú ¬øQu√© es ACO (Ant Colony Optimization)?

ACO (Ant Colony Optimization) es una metaheur√≠stica inspirada en el comportamiento colectivo de las colonias de hormigas.

En la naturaleza, las hormigas encuentran caminos cortos entre su nido y las fuentes de comida dejando feromonas. Cuanto mejor sea el camino (m√°s corto), m√°s feromonas se acumulan, y m√°s probable es que otras hormigas lo sigan, reforzando as√≠ la soluci√≥n.

En el VRPTW, simulamos este comportamiento:

- Cada "hormiga" construye una soluci√≥n recorriendo clientes.
- Las decisiones se toman con base en:
  - **Cantidad de feromona** (lo aprendido)
  - **Visibilidad** (inverso de la distancia)
  - **Factibilidad temporal** (ventanas de tiempo)
- Despu√©s de cada iteraci√≥n, se actualizan las feromonas, favoreciendo los caminos m√°s cortos y temporalmente viables.
- Se respetan las **restricciones de capacidad y tiempo** de cada veh√≠culo.

## üß¨ ¬øQu√© es el Algoritmo Evolutivo Diferencial (DE)?

DE es una t√©cnica de optimizaci√≥n basada en poblaciones. Ideal para problemas continuos y para ajustar par√°metros autom√°ticamente.

üìå Se basa en tres operadores:

Mutaci√≥n ‚Äì Combinaci√≥n de soluciones existentes.

Cruzamiento (recombinaci√≥n) ‚Äì Mezcla de individuo mutado y original.

Selecci√≥n ‚Äì Se elige el m√°s apto entre ambos.

## üß† ¬øC√≥mo se resolvi√≥ el VRPTW?

El enfoque fue **h√≠brido**:

- **ACO** resuelve el VRPTW directamente, respetando las restricciones de capacidad y tiempo.
- **DE** encuentra los mejores par√°metros para ACO.
- **Selecci√≥n Greedy** de veh√≠culos cuando se alcanza la capacidad m√°xima o cuando no es posible cumplir con las ventanas de tiempo.

üéØ **Par√°metros optimizados por DE**:
El algoritmo Evolutivo Diferencial (DE) se utiliz√≥ para calibrar los par√°metros del algoritmo ACO. Los siguientes rangos fueron considerados para cada par√°metro:

- **Œ± (alpha)**: Influencia de la feromona. Ajustado entre **1.0 y 2.5**.
- **Œ≤ (beta)**: Influencia de la visibilidad (heur√≠stica). Ajustado entre **1.0 y 2.5**.
- **Œ≥ (gamma)**: Influencia de la factibilidad temporal. Ajustado entre **0.1 y 2.5**.
- **œÅ (rho)**: Tasa de evaporaci√≥n de feromonas. Ajustado entre **0.1 y 0.9**.
- **N√∫mero de hormigas**: Ajustado entre **20 y 100**.
- **N√∫mero de iteraciones**: Ajustado entre **50 y 200**.

### üìä ¬øC√≥mo se generaron los par√°metros?

Durante la ejecuci√≥n de DE, cada par√°metro fue generado aleatoriamente dentro de los siguientes intervalos:

- **Œ± (alpha)**: Se gener√≥ entre **1.0 y 2.5**.
- **Œ≤ (beta)**: Se gener√≥ entre **1.0 y 2.5**.
- **Œ≥ (gamma)**: Se gener√≥ entre **0.1 y 2.5**.
- **œÅ (rho)**: Se gener√≥ entre **0.1 y 0.9**.
- **N√∫mero de hormigas**: Se gener√≥ entre **20 y 100**.
- **N√∫mero de iteraciones**: Se gener√≥ entre **50 y 200**.

Esto permiti√≥ ajustar de manera eficiente los par√°metros para obtener la mejor soluci√≥n en el VRPTW sin necesidad de hacerlo manualmente.

üîÅ **Proceso combinado**:

1. DE genera una poblaci√≥n de par√°metros.
2. Cada conjunto se eval√∫a ejecutando ACO.
3. Se obtiene la distancia total de todas las rutas generadas y el n√∫mero de veh√≠culos utilizados.
4. DE evoluciona los par√°metros para minimizar la distancia total y el n√∫mero de veh√≠culos.

üìà As√≠ se optimiza el rendimiento de ACO **sin ajustar nada manualmente**.

## üöõ Gesti√≥n de Veh√≠culos, Capacidad y Tiempo

La principal diferencia con respecto al VRP cl√°sico es la incorporaci√≥n de:

- **Restricciones de capacidad**: Cada veh√≠culo tiene una capacidad m√°xima.
- **Demanda de clientes**: Cada cliente requiere cierta cantidad de producto.
- **Ventanas de tiempo**: Cada cliente debe ser visitado dentro de un intervalo de tiempo espec√≠fico.
- **Tiempo de servicio**: Cada cliente requiere un tiempo de servicio determinado.
- **Tiempos de viaje**: El tiempo necesario para viajar entre localizaciones.
- **Selecci√≥n greedy de veh√≠culos**: Cuando un veh√≠culo alcanza su capacidad m√°xima o no puede cumplir con las ventanas de tiempo restantes, se selecciona el siguiente veh√≠culo disponible.

El algoritmo construye las rutas considerando estas restricciones:

1. Comienza desde el dep√≥sito con tiempo inicial 0.
2. Selecciona el siguiente cliente bas√°ndose en feromonas, visibilidad y factibilidad temporal.
3. Verifica si la capacidad del veh√≠culo permite atender al cliente.
4. Verifica si el veh√≠culo puede llegar dentro de la ventana de tiempo del cliente.
5. Actualiza el tiempo de llegada y espera si es necesario.
6. Si no es posible atender al cliente, regresa al dep√≥sito y utiliza el siguiente veh√≠culo.
7. Contin√∫a hasta que todos los clientes sean atendidos.

## üéØ Resultados Esperados

El objetivo principal de este proyecto es encontrar las mejores rutas para el **Problema de Rutas de Veh√≠culos con Ventanas de Tiempo (VRPTW)** mediante el uso combinado del algoritmo **ACO** y el algoritmo **DE** para optimizar los par√°metros.

### üîç ¬øQu√© se espera como salida?

1. **Las mejores rutas encontradas**: Las rutas √≥ptimas para cada veh√≠culo, que minimizan la distancia total recorrida y cumplen con todas las restricciones.
2. **Tiempo de ejecuci√≥n total**: El tiempo total que tom√≥ ejecutar el proceso de optimizaci√≥n y encontrar las mejores rutas.
3. **Utilizaci√≥n de veh√≠culos**: Cantidad de veh√≠culos utilizados y su nivel de ocupaci√≥n.
4. **Planificaci√≥n temporal**: Tiempos de llegada, espera y salida para cada cliente.

### üì¶ Resultados Generados

3. **Archivo JSON**

   - Se genera un archivo `.json` que contiene todos los par√°metros utilizados en la ejecuci√≥n, tales como:
     - Nombre del archivo de entrada
     - Tiempo de ejecuci√≥n en minutos
     - Œ± (alpha), Œ≤ (beta), Œ≥ (gamma), œÅ (rho)
     - N√∫mero de hormigas
     - N√∫mero de iteraciones
     - Valor de fitness de la soluci√≥n
     - Flota:
        - ID_Vehiculo
        - Capacidad Maxima
        - Capacidad Acumulada
        - Tiempo Consumido
        - Tiempo Maximo
        - Numero Clientes
        - Fitness Vehiculo
        - Rutas generada(listas de clientes)

4. **Imagen simulada**

   - Se genera una imagen est√°tica (`.png`) que representa visualmente las **rutas generadas** por el algoritmo ACO.
   - Las rutas de diferentes veh√≠culos se representan con colores distintos.
   - Incluye informaci√≥n sobre las ventanas de tiempo de cada cliente.

   Ejemplo de visualizaci√≥n:
   ![Imagen_VRPTW](Recursos_Readme/Ejemplo_png.png)

5. **GIF simulado**

   - Se crea un **GIF animado** que simula el proceso de construcci√≥n de las rutas en el tiempo, mostrando c√≥mo los veh√≠culos recorren los clientes respetando las ventanas de tiempo.

   Ejemplo de animaci√≥n:
   ![Simulacion VRPTW](Recursos_Readme/Ejemplo_gif.gif)

### üíæ Ejemplo de archivo JSON

El archivo `JSON` generado tendr√° la siguiente estructura:

```json
{
	"Archivo":	"C101_(25)",
	"Tiempo Ejecucion en Minutos":	1,
	"Alpha":	2.01145185926531,
	"Beta":	1.1645681097472869,
	"Gamma":	1.1346780471665217,
	"Rho":	0.14182290064255842,
	"Numero Hormigas":	62,
	"Numero Iteraciones":	175,
	"Fitness Global":	191.8136197786562,
	"flota":	[{
			"Id_vehiculo":	1,
			"Capacidad Maxima":	200,
			"Capacidad Acumulada":	160,
			"Tiempo Consumido":	1236,
			"Tiempo Maximo":	1236,
			"Numero Clientes":	11,
			"Fitness Vehiculo":	59.488230933533082,
			"Ruta Clientes":	[0, 5, 3, 7, 8, 10, 11, 9, 6, 4, 2, 1, 0]
		}, {
			"Id_vehiculo":	2,
			"Capacidad Maxima":	200,
			"Capacidad Acumulada":	190,
			"Tiempo Consumido":	1236,
			"Tiempo Maximo":	1236,
			"Numero Clientes":	8,
			"Fitness Vehiculo":	95.884709130818266,
			"Ruta Clientes":	[0, 13, 17, 18, 19, 15, 16, 14, 12, 0]
		}, {
			"Id_vehiculo":	3,
			"Capacidad Maxima":	200,
			"Capacidad Acumulada":	110,
			"Tiempo Consumido":	1007.2426406871193,
			"Tiempo Maximo":	1236,
			"Numero Clientes":	6,
			"Fitness Vehiculo":	36.440679714304849,
			"Ruta Clientes":	[0, 20, 24, 25, 23, 22, 21, 0]
		}]
}
```

## Requisitos

Para ejecutar este proyecto, aseg√∫rate de tener lo siguiente:

### üßë‚Äçüíª C Compiler

Es necesario tener un compilador de C instalado (como gcc) para compilar el c√≥digo fuente.

### Librer√≠a `cJSON`:

Este proyecto requiere la librer√≠a `cJSON` para trabajar con archivos JSON en C.  
 Puedes encontrarla y consultar c√≥mo instalarla en su repositorio oficial:

üëâ [https://github.com/DaveGamble/cJSON](https://github.com/DaveGamble/cJSON)

### üì¶ Python

Aseg√∫rate de tener Python instalado junto con las siguientes bibliotecas:

- json
- os
- sys
- matplotlib
- numpy

## Compilaci√≥n y Ejecuci√≥n

### 1. **Compilaci√≥n**

Para compilar el proyecto, usa el siguiente comando:

```bash
make
```

Este comando compilar√° el c√≥digo en modo release por defecto (optimizado). Si prefieres compilar en modo debug para facilitar la depuraci√≥n, puedes usar:

```bash
make debug
```

### 2. Ejecutar el Programa

Una vez compilado el proyecto, puedes ejecutar el ejecutable generado (llamado main) con los siguientes par√°metros:

```bash
./main <poblacion> <generaciones> <archivo> <numero_de_clientes>
```

Ejemplo:

```bash
./main 50 100 C101 25
```

- poblacion: el tama√±o de la poblaci√≥n para el algoritmo.
- generaciones: el n√∫mero de generaciones que el algoritmo debe ejecutar.
- archivo: el archivo de entrada.
- numero_de_clientes: el n√∫mero de clientes a considerar en el VRPTW.

### 3. Limpieza

Si deseas limpiar los archivos generados (archivos objeto, ejecutables, etc.), puedes usar:

```bash
make clean
```

## üìÅ Estructura del Proyecto

```bash
.
‚îú‚îÄ‚îÄ build/                     # Archivos objetos y dependencias generados por el compilador
‚îú‚îÄ‚îÄ include/                  # Archivos de cabecera (.h)
‚îÇ   ‚îú‚îÄ‚îÄ aed.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_vrp_tw.h  # Modificado para VRPTW
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.h
‚îÇ   ‚îú‚îÄ‚îÄ estructuras.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.h
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.h
‚îÇ   ‚îî‚îÄ‚îÄ vrp_tw_aco.h            # Modificado para VRPTW
‚îú‚îÄ‚îÄ Instancias/               # Instancias CSV utilizadas en la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_25/
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_50/
‚îÇ   ‚îî‚îÄ‚îÄ Instancias_100/
‚îú‚îÄ‚îÄ main                      # Ejecutable generado tras compilar
‚îú‚îÄ‚îÄ makefile                  # Makefile para compilar el proyecto
‚îú‚îÄ‚îÄ README.md                 # Archivo de documentaci√≥n
‚îú‚îÄ‚îÄ Resultados/               # Salidas generadas por la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_25/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_50/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îî‚îÄ‚îÄ Resultados_100/
‚îÇ       ‚îú‚îÄ‚îÄ Gifs/
‚îÇ       ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ       ‚îî‚îÄ‚îÄ Json/
‚îú‚îÄ‚îÄ src/                      # C√≥digo fuente del proyecto en C y Python
‚îÇ   ‚îú‚îÄ‚îÄ aed.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_vrp_tw.c  # Modificado para VRPTW
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.c
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.c
‚îÇ   ‚îú‚îÄ‚îÄ vrp_tw_aco.c           # Modificado para VRPTW
‚îÇ   ‚îî‚îÄ‚îÄ Simulador_VRP_TW/      # Modificado para VRPTW
‚îÇ       ‚îî‚îÄ‚îÄ simulador_vrp_tw.py
‚îî‚îÄ‚îÄ VRP_Solomon/              # Instancias del benchmark Solomon para VRPTW
    ‚îú‚îÄ‚îÄ VRP_Solomon_25/
    ‚îÇ   ‚îú‚îÄ‚îÄ C101_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C201_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R101_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R201_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC101_(25).txt
    ‚îÇ   ‚îî‚îÄ‚îÄ RC201_(25).txt
    ‚îú‚îÄ‚îÄ VRP_Solomon_50/
    ‚îÇ   ‚îú‚îÄ‚îÄ C101_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C201_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R101_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R201_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC101_(50).txt
    ‚îÇ   ‚îî‚îÄ‚îÄ RC201_(50).txt
    ‚îî‚îÄ‚îÄ VRP_Solomon_100/
        ‚îú‚îÄ‚îÄ C101_(100).txt
        ‚îú‚îÄ‚îÄ C201_(100).txt
        ‚îú‚îÄ‚îÄ R101_(100).txt
        ‚îú‚îÄ‚îÄ R201_(100).txt
        ‚îî‚îÄ‚îÄ RC101_(100).txt
```

### ‚úÖ Consideraciones finales

Este trabajo busca contribuir al estudio y soluci√≥n del problema VRPTW mediante la implementaci√≥n de algoritmos bioinspirados. La principal diferencia respecto a la versi√≥n VRP cl√°sica es la incorporaci√≥n de restricciones de ventanas de tiempo, lo que a√±ade una capa de complejidad al problema y requiere una gesti√≥n temporal durante la construcci√≥n de las rutas. Se invita a la comunidad a explorar, reutilizar y mejorar el c√≥digo seg√∫n sus necesidades.

## üë• Contribuciones

- üßë‚Äçüè´ **Dr. Edwin Montes Orozco**  
  Director de PT y responsable del acompa√±amiento acad√©mico durante el desarrollo del proyecto.

- üë®‚Äçüíª **Alejandro Mart√≠nez Guzm√°n**  
  Autor del proyecto. Encargado del dise√±o, implementaci√≥n y documentaci√≥n del sistema de optimizaci√≥n.

- üß™ **Jaime L√≥pez Lara**  
  Ayudante en la ejecuci√≥n del c√≥digo y recolecci√≥n de resultados.

## üìù Licencia

Este proyecto est√° licenciado bajo los t√©rminos de la licencia MIT.  
Consulta el archivo [LICENSE](./LICENSE) para m√°s detalles.
