\documentclass[12pt,titlepage,twoside,openright]{book}
\usepackage{color}
\usepackage{pstricks, pst-node}
\usepackage{graphics,graphicx,graphpap}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\pagestyle{empty}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Plantilla elaborada por Alma Rocío Sagaceta Mejía (2010) y modificada por Julián Alberto Fresán Figueroa (2011-2020) %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Aqui se pueden agregar palabras que Latex separa de forma incorrecta al haber saltos de linea. Al escribir fa-mi-lia se le esta indicando que puede separar la palabra solo en los guiones
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hyphenation{Colores fa-mi-lia caracte-rizarlos}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%              UAM-Logo                   	 %%%
%%%         Por Ismael Velázquez Ramírez         %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\uamlogo}[3][2pt]{
    \psset{unit=#2,linewidth=#1 }
    \psline*[linearc=.25,linecolor=#3](2.8,2)(2,2)(1.8,0)(2.8,2)(3.8,0)(3.6,2)(2,2)(1.8,0)
    \psline*[linecolor=#3](0,0)(.8,0)(1.8,2)(1,2)(0,0)
    \psline*[linecolor=#3](4.8,0)(3.8,2)(4.6,2)(5.6,0)(4.8,0)
    \psline*[linearc=.25,linecolor=#3](3.8,0)(2.8,2)(3.6,2)(4.6,0)(3.8,0)
    \psline*[linearc=.25,linecolor=#3](4.6,0)(3.8,0)(2.8,2)(3.6,2)(4.6,0)
    \rput{180}(5.6,2){%
    \psline*[linearc=.25,linecolor=white](2.8,2)(2,2)(1.8,0)(2.8,2)(3.8,0)(3.6,2)(2,2)(1.8,0)
    \psline*[linearc=.25,linecolor=white](1,0)(1.8,0)(2.8,2)(2,2)(1,0)
    \psline*[linearc=.25,linecolor=white](1.8,0)(1,0)(2,2)(2.8,2)(1.8,0)
    \psline*[linearc=.25,linecolor=white](3.8,0)(2.8,2)(3.6,2)(4.6,0)(3.8,0)
    \psline*[linearc=.25,linecolor=white](4.6,0)(3.8,0)(2.8,2)(3.6,2)(4.6,0)
    \psline[linearc=.25,linecolor=#3](1,0)(2,2)(3.6,2)(4.6,0)
    \psline[linecolor=#3](1,0)(1.8,0)
    \psline[linearc=.25,linecolor=#3](4.6,0)(3.8,0)
    \psline[linearc=.25,linecolor=#3](1.8,0)(2.8,2)(3.8,0)}
    \psline*[linearc=.25,linecolor=#3](1,0)(1.8,0)(2.8,2)(2,2)(1,0)
    \psline*[linearc=.25,linecolor=#3](1.8,0)(1,0)(2,2)(2.8,2)(1.8,0)}
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aqui se definen los entornos en español.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{teo}{Teorema}
\newtheorem{defi}{Definici\'on}
\newtheorem{coro}{Corolario}


%Ejemplo de uso:
%\begin{teo}[Teorema de Completitud] 
%Sea...
%\end{teo}



\newcommand{\titulo}[1]{\def\eltitulo{#1}}
\newcommand{\carrera}[1]{\def\lacarrera{#1}}
\newcommand{\nombre}[1]{\def\elnombre{#1}}    %* Del alumno
\newcommand{\director}[1]{\def\eldirector{#1}}  %* De tesis
\newcommand{\fecha}[1]{\def\lafecha{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Se deben llenar los siguientes datos
%Estos datos apareceran en la portada y los encabezados
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titulo{Nombre del Proyecto}
\nombre{\uppercase{Nombre del alumno}}
\carrera{Licenciatura en ...}
\director{\uppercase{Nombre del asesor(es)}}
\fecha{Mes y a\~no (de finalizaci\'on)}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Portada
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{empty}

\hskip-1.5cm
\begin{minipage}[c][5cm][s]{4cm}
	\begin{center}
		%\rput(-2,.5){\uamlogo{.75}{black}}


		\hskip2pt \vrule width2pt height16cm\hskip1mm
		\vrule width1pt height16cm\\[10pt]

	\end{center}
\end{minipage}\quad
%% Barra derecha - TÃ­Â­tulos
\begin{minipage}[c][9.5cm][s]{10cm}
	\begin{center}
		% Barra superior
		{\Large \scshape Universidad Aut\'onoma Metropolitana}
		\vspace{.3cm}
		\hrule height2pt
		\vspace{.1cm}
		\hrule height1pt
		\vspace{.3cm}
		% \scshape
		{ UNIDAD CUAJIMALPA}


		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Poner aquí el título del trabajo
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\vspace{2cm}

		{\Large \textsc{GREEN-VRP}}

		\vspace{2cm}
		\makebox[8cm][c]{\Large Proyecto Terminal}\\[8pt]


		\makebox[6cm]{QUE PRESENTA:}\\[3pt]
		\elnombre\\
		\vspace{.5cm}
		{\textsc {\large \lacarrera}}\\[3pt]
		\makebox[10cm]{Departamento de Matem\'aticas Aplicadas e Ingenier\'{i}a}\\[13pt]
		\makebox[10cm]{Divisi\'on de Ciencias Naturales e Ingenier\'ia}\\[13pt]


		\vspace{2cm}

		{ Asesor y Responsable de la tesis:\\ \eldirector\\}

		\vspace{2cm}
		\begin{flushright}
			\lafecha
		\end{flushright}

	\end{center}
\end{minipage}


\frontmatter{}



\pagestyle{plain}


\tableofcontents
\newpage
\listoffigures




\mainmatter{}
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{%
	\markboth{\chaptername
		\ \thechapter.\ #1}{}}
\fancyhead[RO,LE]{\bfseries \thepage}
\fancyfoot{}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1.5ex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aquí se empieza a colocar la información del trabajo
% El documento deberá contener al menos los  capítulos que aparecen a continuación.
% Cada capitulo puede tener secciones y subsecciones
% Las imágenes deben ser incluidas en formato .eps
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Resumen}

%Uno o dos párrafos de que se hizo en el proyecto terminal


\chapter{Introducci\'on}
%una o dos p\'aginas, escrita para ser comprensible por cualquier persona
\chapter{Conocimientos preliminares}
%En este capítulo deberán incluir todos los conocimientos necesarios para poder entender los temas que se trataron en el proyecto. 
\section{Problema de Optimizaci\'on}

La optimizaci\'on es una rama de las matem\'aticas aplicadas que se enfoca en el desarrollo de principios y m\'etodos para resolver problemas cuantitativos en diversas disciplinas como la f\'isica, biolog\'ia, ingenier\'ia o econom\'ia, as\'i como en cualquier campo donde sea necesaria la toma de decisiones dentro de un conjunto de opciones, con el objetivo de encontrar la mejor o una de las mejores soluciones de manera eficiente.

En t\'erminos formales, consideramos una funci\'on \( f : S \rightarrow \mathbb{R} \), donde \( S \subseteq \mathbb{R}^n \). Denominaremos a \( f \) como funci\'on objetivo, y a \( S \) lo llamaremos conjunto factible o conjunto de soluciones posibles.

\section{Tipos de Optimizaci\'on}

Dentro de la optimizaci\'on, existen dos tipos principales: la optimizaci\'on discreta y la optimizaci\'on continua.

La optimizaci\'on discreta se aplica cuando el dominio \( S \) de la funci\'on objetivo es un conjunto discreto. En este contexto, el conjunto de soluciones posibles es finito o numerablemente infinito. La optimizaci\'on discreta a menudo involucra la b\'usqueda de soluciones en combinaciones espec\'ificas y puede involucrar problemas como la programaci\'on lineal entera o los problemas de asignaci\'on. Las soluciones \'optimas pueden ser dif\'iciles de encontrar debido a la naturaleza combinatoria del problema.

Por otro lado, la optimizaci\'on continua se refiere a situaciones en las que el conjunto \( S \) de la funci\'on objetivo es un conjunto continuo. En este caso, el dominio es un intervalo o un subconjunto de \( \mathbb{R}^n \) que no es discreto. Aqu\'i se buscan soluciones que maximizan o minimizan la funci\'on objetivo sobre un espacio continuo, y los m\'etodos comunes incluyen la programaci\'on lineal, la programaci\'on no lineal y el c\'alculo de variaciones. La optimizaci\'on continua suele implicar el uso de t\'ecnicas de c\'alculo y an\'alisis matem\'atico.

%\subsection{Optimizaci\'on Discreta}

%\subsection{Optimizaci\'on continua}

\section{Heur\'istica y Metaheur\'istica}

La palabra ``heur\'istica" proviene del t\'ermino griego ``euriskein", que significa ``encontrar".
En el contexto de la optimizaci\'on, se refiere a t\'ecnicas dise\~nadas para mejorar o resolver problemas que, de otra manera, no tendr\'ian una soluci\'on eficiente. Los algoritmos heur\'isticos ayudan a encontrar soluciones aproximadas para problemas cuyas soluciones exactas no son factibles en tiempos polinomiales.
Muchos algoritmos de inteligencia artificial son heur\'isticos o se basan en sus principios para resolver problemas.

El prefijo ``meta" otorga un sentido de mayor nivel a la palabra heur\'istica, lo que permite abordar problemas de mayor complejidad mediante soluciones factibles.

Tanto las heur\'isticas como las metaheur\'isticas se pueden utilizar de manera intercambiable para resolver problemas de optimizaci\'on combinatoria.

\section{Complejidad P, NP, NP-completo y NP-dif\'icil}

En computaci\'on, un algoritmo es un procedimiento que resuelve un problema paso a paso, generando una salida a partir de una entrada en un n\'umero finito de pasos. La eficiencia de un algoritmo se eval\'ua a trav\'es de su complejidad temporal, la cual se mide en funci\'on del tama\~no de la entrada. Esto nos permite clasificar los problemas en diferentes clases de complejidad, como P, NP, NP-completo y NP-dif\'icil.

La clase P contiene problemas que pueden resolverse eficientemente (en tiempo polinomial), mientras que la clase NP contiene aquellos problemas cuyas soluciones pueden verificarse eficientemente. Las clases NP-completo y NP-dif\'icil incluyen problemas m\'as complejos; resolver uno de estos de manera eficiente significar\'ia resolver eficientemente cualquier problema en NP. Esto nos lleva al problema fundamental en teor\'ia de la computaci\'on: P vs NP.

\subsection{Complejidad P}

En la teor\'ia de la complejidad, nos enfocamos principalmente en problemas de decisi\'on, aquellos donde la respuesta es un simple "s\'i" o "no". La clase P est\'a compuesta por problemas que pueden ser resueltos en tiempo polinomial. Esto significa que existe un algoritmo que, dado un problema de tama\~no $n$, puede resolverlo en un tiempo que crece a lo sumo como un polinomio de $n$.

\subsubsection{Ejemplo: Algoritmo de Ordenamiento por Selecci\'on}

El algoritmo de ordenamiento por selecci\'on es un m\'etodo simple para ordenar una lista de elementos, aunque no es el m\'as eficiente para listas grandes. A continuaci\'on, se presenta una explicaci\'on detallada del algoritmo, su funcionamiento, complejidad y caracter\'isticas.

\paragraph{Descripci\'on del algoritmo}
El algoritmo selecciona repetidamente el elemento m\'inimo de la lista y lo coloca en su posici\'on correcta. Consideremos la lista (3 1 6 8 2). El proceso de ordenamiento ser\'ia:

\begin{enumerate}
    \item (3 1 6 8 2) - Estado inicial
    \item (1 3 6 8 2) - Se intercambia 1 (m\'inimo) con 3
    \item (1 2 6 8 3) - Se intercambia 2 con 3
    \item (1 2 3 8 6) - Se intercambia 3 con 6
    \item (1 2 3 6 8) - Se intercambia 6 con 8
    \item (1 2 3 6 8) - La lista est\'a ordenada
\end{enumerate}

\paragraph{Representaci\'on matem\'atica:}
Para una lista de $n$ elementos:
\begin{itemize}
    \item Primera pasada: $n-1$ comparaciones
    \item Segunda pasada: $n-2$ comparaciones
    \item $\vdots$
    \item \'Ultima pasada: 1 comparaci\'on
\end{itemize}

\paragraph{Complejidad:}
El n\'umero total de comparaciones es $(n-1) + (n-2) + \dots + 2 + 1 = \frac{n(n-1)}{2}$, lo que da una complejidad de $O(n^2)$.

El algoritmo de ordenamiento por selecci\'on, aunque simple de entender e implementar, no es eficiente para listas grandes debido a su complejidad cuadr\'atica. Sin embargo, su tiempo de ejecuci\'on es polinomial, por lo que pertenece a la clase P.

\subsection{Clase de complejidad NP}

La clase NP abarca problemas donde una soluci\'on afirmativa ("s\i") puede verificarse en tiempo polinomial. En estos problemas, existe un testigo o certificado que sirve como prueba de la validez de la respuesta, y un algoritmo verificador que puede validar este testigo eficientemente.

Un ejemplo cl\'asico es el problema de la suma de subconjuntos: dado un conjunto de $n$ n\'umeros, se busca si existe un subconjunto cuya suma sea $S$. Para verificar una soluci\'on afirmativa, bastar\'ia con que nos dieran el subconjunto en cuesti\'on, y en tiempo lineal podr\'iamos sumar sus elementos para comprobar que la suma es correcta.

Al igual que en P, los problemas en NP pueden incluir aquellos que ya mencionamos, pero con una importante distinci\'on: aunque podemos verificar soluciones en tiempo polinomial, no necesariamente podemos encontrarlas r\'apidamente. De hecho, uno de los grandes interrogantes en teor\'ia de la complejidad es si todos los problemas en NP pueden ser tambi\'en resueltos en tiempo polinomial.

\subsubsection{Ejemplo de problema NP: El Problema del Agente Viajero}

El Problema del Agente Viajero (TSP, por sus siglas en ingl\'es) es un ejemplo claro de un problema NP. El objetivo es encontrar una trayectoria que visite todas las $n$ ciudades exactamente una vez y regrese a la ciudad de origen, minimizando el costo total del recorrido.

\paragraph{Datos del problema:}
\begin{itemize}
    \item Un entero $n > 0$, que representa el n\'umero de ciudades.
    \item Una matriz de distancias $(d_{ij})$ de dimensi\'on $n \times n$, donde $d_{ij}$ es un entero mayor o igual a cero que representa la distancia entre la ciudad $i$ y la ciudad $j$.
\end{itemize}

\paragraph{Representaci\'on matem\'atica:}
Una permutaci\'on $\pi$ c\'iclica representa un recorrido, donde $\pi(j)$ se interpreta como la ciudad que sigue a la ciudad $j$ para $j = 1, 2, \dots, n$.

\paragraph{Costo del recorrido:}
El costo del recorrido se calcula mediante la siguiente f\'ormula:

\[
\sum_{j=1}^n d_{j,\pi(j)}
\]

Donde:
\begin{itemize}
    \item $j$ recorre todas las ciudades de 1 a $n$.
    \item $d_{j,\pi(j)}$ representa la distancia entre la ciudad $j$ y la ciudad que le sigue en el recorrido seg\'un la permutaci\'on $\pi$.
\end{itemize}

\paragraph{Complejidad:}
El Problema del Agente Viajero pertenece a la clase NP. Si nos dieran una soluci\'on (un recorrido), podr\'iamos verificar si es v\'alida y calcular su costo en tiempo polinomial. Sin embargo, encontrar la soluci\'on \'optima no se conoce como un problema que pueda resolverse en tiempo polinomial para todos los casos.

\subsection{Reducciones y las clases NP-completo y NP-dif\'icil}

Para profundizar en las clases de NP-completo y NP-dif\'icil, es esencial introducir el concepto de reducci\'on. Una reducci\'on entre problemas significa que si podemos resolver un problema de manera eficiente, entonces tambi\'en podemos resolver el otro. Esto es clave para entender la relaci\'on entre los problemas de estas clases.

\subsubsection{Definici\'on de Reducci\'on Polinomial}

Dado un problema A y un problema B, diremos que existe una reducci\'on polinomial de A a B si cualquier instancia de A puede ser transformada en una instancia de B en tiempo polinomial, de manera que resolver B implica resolver A.

Esto nos lleva a la clase de complejidad NP-dif\'icil, que est\'a compuesta por problemas a los cuales cualquier problema en NP puede ser reducido. NP-completo, por otro lado, incluye aquellos problemas que son tanto NP-dif\'iciles como pertenecientes a NP. Si alguna vez encontr\'aramos un algoritmo eficiente para resolver un problema NP-completo, entonces podr\'iamos resolver todos los problemas en NP de manera eficiente.

En resumen las clases de complejidad P, NP, NP-completo y NP-dif\'icil son fundamentales para comprender la eficiencia de los algoritmos. El problema abierto m\'as importante de la teor\'ia de la computaci\'on, P vs NP, sigue siendo una pregunta sin respuesta: ¿Podemos resolver todos los problemas que podemos verificar eficientemente? Resolver esta pregunta tendr\'ia implicaciones profundas no solo en la teor\'ia, sino en muchas \'areas pr\'acticas de la computaci\'on.

\chapter{Desarrollo del proyecto}
%En Este capítulo se incluirán los resultados obtenidos durante el proyecto

\chapter{Conclusiones y trabajo futuro}
%En este capítulo se incluirán las conclusiones y posibles líneas de trabajo que podrían surgir a partir de este proyecto


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% La bibliografía debe aparecer de manera homologada
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{0}
	%\bibitem{}

\end{thebibliography}

\end{document}


