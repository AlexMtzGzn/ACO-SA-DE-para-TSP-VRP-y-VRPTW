\documentclass[12pt,titlepage,twoside,openright]{book}
\usepackage{color}
\usepackage{pstricks, pst-node}
\usepackage{graphics,graphicx,graphpap}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\pagestyle{empty}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Plantilla elaborada por Alma Rocío Sagaceta Mejía (2010) y modificada por Julián Alberto Fresán Figueroa (2011-2020) %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Aqui se pueden agregar palabras que Latex separa de forma incorrecta al haber saltos de linea. Al escribir fa-mi-lia se le esta indicando que puede separar la palabra solo en los guiones
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hyphenation{Colores fa-mi-lia caracte-rizarlos}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%              UAM-Logo                   	 %%%
%%%         Por Ismael Velázquez Ramírez         %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\uamlogo}[3][2pt]{
    \psset{unit=#2,linewidth=#1 }
    \psline*[linearc=.25,linecolor=#3](2.8,2)(2,2)(1.8,0)(2.8,2)(3.8,0)(3.6,2)(2,2)(1.8,0)
    \psline*[linecolor=#3](0,0)(.8,0)(1.8,2)(1,2)(0,0)
    \psline*[linecolor=#3](4.8,0)(3.8,2)(4.6,2)(5.6,0)(4.8,0)
    \psline*[linearc=.25,linecolor=#3](3.8,0)(2.8,2)(3.6,2)(4.6,0)(3.8,0)
    \psline*[linearc=.25,linecolor=#3](4.6,0)(3.8,0)(2.8,2)(3.6,2)(4.6,0)
    \rput{180}(5.6,2){%
    \psline*[linearc=.25,linecolor=white](2.8,2)(2,2)(1.8,0)(2.8,2)(3.8,0)(3.6,2)(2,2)(1.8,0)
    \psline*[linearc=.25,linecolor=white](1,0)(1.8,0)(2.8,2)(2,2)(1,0)
    \psline*[linearc=.25,linecolor=white](1.8,0)(1,0)(2,2)(2.8,2)(1.8,0)
    \psline*[linearc=.25,linecolor=white](3.8,0)(2.8,2)(3.6,2)(4.6,0)(3.8,0)
    \psline*[linearc=.25,linecolor=white](4.6,0)(3.8,0)(2.8,2)(3.6,2)(4.6,0)
    \psline[linearc=.25,linecolor=#3](1,0)(2,2)(3.6,2)(4.6,0)
    \psline[linecolor=#3](1,0)(1.8,0)
    \psline[linearc=.25,linecolor=#3](4.6,0)(3.8,0)
    \psline[linearc=.25,linecolor=#3](1.8,0)(2.8,2)(3.8,0)}
    \psline*[linearc=.25,linecolor=#3](1,0)(1.8,0)(2.8,2)(2,2)(1,0)
    \psline*[linearc=.25,linecolor=#3](1.8,0)(1,0)(2,2)(2.8,2)(1.8,0)}
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aqui se definen los entornos en español.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{teo}{Teorema}
\newtheorem{defi}{Definici\'on}
\newtheorem{coro}{Corolario}


%Ejemplo de uso:
%\begin{teo}[Teorema de Completitud] 
%Sea...
%\end{teo}



\newcommand{\titulo}[1]{\def\eltitulo{#1}}
\newcommand{\carrera}[1]{\def\lacarrera{#1}}
\newcommand{\nombre}[1]{\def\elnombre{#1}}    %* Del alumno
\newcommand{\director}[1]{\def\eldirector{#1}}  %* De tesis
\newcommand{\fecha}[1]{\def\lafecha{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Se deben llenar los siguientes datos
%Estos datos apareceran en la portada y los encabezados
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titulo{Nombre del Proyecto}
\nombre{\uppercase{Nombre del alumno}}
\carrera{Licenciatura en ...}
\director{\uppercase{Nombre del asesor(es)}}
\fecha{Mes y a\~no (de finalizaci\'on)}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Portada
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{empty}

\hskip-1.5cm
\begin{minipage}[c][5cm][s]{4cm}
	\begin{center}
		%\rput(-2,.5){\uamlogo{.75}{black}}


		\hskip2pt \vrule width2pt height16cm\hskip1mm
		\vrule width1pt height16cm\\[10pt]

	\end{center}
\end{minipage}\quad
%% Barra derecha - TÃ­Â­tulos
\begin{minipage}[c][9.5cm][s]{10cm}
	\begin{center}
		% Barra superior
		{\Large \scshape Universidad Aut\'onoma Metropolitana}
		\vspace{.3cm}
		\hrule height2pt
		\vspace{.1cm}
		\hrule height1pt
		\vspace{.3cm}
		% \scshape
		{ UNIDAD CUAJIMALPA}


		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Poner aquí el título del trabajo
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\vspace{2cm}

		{\Large \textsc{GREEN-VRP}}

		\vspace{2cm}
		\makebox[8cm][c]{\Large Proyecto Terminal}\\[8pt]


		\makebox[6cm]{QUE PRESENTA:}\\[3pt]
		\elnombre\\
		\vspace{.5cm}
		{\textsc {\large \lacarrera}}\\[3pt]
		\makebox[10cm]{Departamento de Matem\'aticas Aplicadas e Ingenier\'{i}a}\\[13pt]
		\makebox[10cm]{Divisi\'on de Ciencias Naturales e Ingenier\'ia}\\[13pt]


		\vspace{2cm}

		{ Asesor y Responsable de la tesis:\\ \eldirector\\}

		\vspace{2cm}
		\begin{flushright}
			\lafecha
		\end{flushright}

	\end{center}
\end{minipage}


\frontmatter{}



\pagestyle{plain}


\tableofcontents
\newpage
\listoffigures




\mainmatter{}
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{%
	\markboth{\chaptername
		\ \thechapter.\ #1}{}}
\fancyhead[RO,LE]{\bfseries \thepage}
\fancyfoot{}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1.5ex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aquí se empieza a colocar la información del trabajo
% El documento deberá contener al menos los  capítulos que aparecen a continuación.
% Cada capitulo puede tener secciones y subsecciones
% Las imágenes deben ser incluidas en formato .eps
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Resumen}

%Uno o dos párrafos de que se hizo en el proyecto terminal


\chapter{Introducci\'on}
%una o dos p\'aginas, escrita para ser comprensible por cualquier persona
\chapter{Conocimientos preliminares}
%En este capítulo deberán incluir todos los conocimientos necesarios para poder entender los temas que se trataron en el proyecto. 
\section{Problema de Optimizaci\'on}

La optimizaci\'on es una rama de las matem\'aticas aplicadas que se enfoca en el desarrollo de principios y m\'etodos para resolver problemas cuantitativos en diversas disciplinas como la f\'isica, biolog\'ia, ingenier\'ia o econom\'ia, as\'i como en cualquier campo donde sea necesaria la toma de decisiones dentro de un conjunto de opciones, con el objetivo de encontrar la mejor o una de las mejores soluciones de manera eficiente.

En t\'erminos formales, consideramos una funci\'on \( f : S \rightarrow \mathbb{R} \), donde \( S \subseteq \mathbb{R}^n \). Denominaremos a \( f \) como funci\'on objetivo, y a \( S \) lo llamaremos conjunto factible o conjunto de soluciones posibles.

\section{Tipos de Optimizaci\'on}

Dentro de la optimizaci\'on, existen dos tipos principales: la optimizaci\'on discreta y la optimizaci\'on continua.

La optimizaci\'on discreta se aplica cuando el dominio \( S \) de la funci\'on objetivo es un conjunto discreto. En este contexto, el conjunto de soluciones posibles es finito o numerablemente infinito. La optimizaci\'on discreta a menudo involucra la b\'usqueda de soluciones en combinaciones espec\'ificas y puede involucrar problemas como la programaci\'on lineal entera o los problemas de asignaci\'on. Las soluciones \'optimas pueden ser dif\'iciles de encontrar debido a la naturaleza combinatoria del problema.

Por otro lado, la optimizaci\'on continua se refiere a situaciones en las que el conjunto \( S \) de la funci\'on objetivo es un conjunto continuo. En este caso, el dominio es un intervalo o un subconjunto de \( \mathbb{R}^n \) que no es discreto. Aqu\'i se buscan soluciones que maximizan o minimizan la funci\'on objetivo sobre un espacio continuo, y los m\'etodos comunes incluyen la programaci\'on lineal, la programaci\'on no lineal y el c\'alculo de variaciones. La optimizaci\'on continua suele implicar el uso de t\'ecnicas de c\'alculo y an\'alisis matem\'atico.

%\subsection{Optimizaci\'on Discreta}

%\subsection{Optimizaci\'on continua}

\section{Heur\'istica y Metaheur\'istica}

La palabra ``heur\'istica'' proviene del t\'ermino griego ``euriskein'', que significa ``encontrar''.
En el contexto de la optimizaci\'on, se refiere a t\'ecnicas dise\~nadas para mejorar o resolver problemas que, de otra manera, no tendr\'ian una soluci\'on eficiente. Los algoritmos heur\'isticos ayudan a encontrar soluciones aproximadas para problemas cuyas soluciones exactas no son factibles en tiempos polinomiales.
Muchos algoritmos de inteligencia artificial son heur\'isticos o se basan en sus principios para resolver problemas.

El prefijo ``meta'' otorga un sentido de mayor nivel a la palabra heur\'istica, lo que permite abordar problemas de mayor complejidad mediante soluciones factibles.

Tanto las heur\'isticas como las metaheur\'isticas se pueden utilizar de manera intercambiable para resolver problemas de optimizaci\'on combinatoria.

\section{Complejidad P, NP, NP-completo y NP-difícil}

\subsection{Introducción a la Complejidad Algorítmica}

En computación, un algoritmo es un procedimiento que resuelve un problema paso a paso, generando una salida a partir de una entrada en un número finito de pasos. La complejidad y el tiempo de ejecución de un algoritmo se determinan por su acotamiento mediante un polinomio en función del tamaño de entrada, lo cual nos ayuda a evaluar su eficiencia.

Los algoritmos se clasifican en distintas clases de complejidad dependiendo del algoritmo más eficiente conocido para resolverlos: P, NP, NP-completo y NP-difícil. La clase P contiene problemas que pueden ser resueltos de forma eficiente, mientras que NP abarca aquellos cuya solución puede verificarse rápidamente. Las clases NP-completo y NP-difícil incluyen problemas de mayor complejidad; resolver uno de estos de manera eficiente implicaría la resolución eficiente de cualquier problema en NP. Esto nos lleva al problema fundamental en teoría de la computación: P vs NP.

\subsection{Complejidad P}

En la teoría de la complejidad, nos enfocamos principalmente en problemas de decisión, aquellos donde la respuesta es un simple "sí" o "no". La clase P está compuesta por problemas que pueden ser resueltos en tiempo polinomial. Esto significa que existe un algoritmo que, dado un problema de tamaño $n$, puede resolverlo en un tiempo que crece a lo sumo como un polinomio de $n$.

\subsubsection{Ejemplo: Algoritmo de Ordenamiento por Selección}

El algoritmo de ordenamiento por selección es un método simple pero ineficiente para ordenar una lista de elementos. A continuación, se presenta una explicación detallada del algoritmo, su funcionamiento, complejidad y características.

\paragraph{Ejemplo Paso a Paso}
Consideremos la lista (3 1 6 8 2). El proceso de ordenamiento sería:

\begin{enumerate}
    \item (3 1 6 8 2) - Estado inicial
    \item (1 3 6 8 2) - Se intercambia 1 (mínimo) con 3
    \item (1 2 6 8 3) - Se intercambia 2 con 3
    \item (1 2 3 8 6) - Se intercambia 3 con 6
    \item (1 2 3 6 8) - Se intercambia 6 con 8
    \item (1 2 3 6 8) - La lista está ordenada
\end{enumerate}

\paragraph{Análisis de Complejidad}
Número de Comparaciones:
Para una lista de $n$ elementos:
\begin{itemize}
    \item Primera pasada: $n-1$ comparaciones
    \item Segunda pasada: $n-2$ comparaciones
    \item $\vdots$
    \item Última pasada: 1 comparación
\end{itemize}
Total de comparaciones: $(n-1) + (n-2) + \cdots + 2 + 1 = \frac{n(n-1)}{2}$

El algoritmo de ordenamiento por selección, aunque simple de entender e implementar, no es eficiente para listas grandes debido a su complejidad cuadrática. Sin embargo, puede ser útil en ciertos escenarios, como cuando el costo de intercambio es significativamente mayor que el costo de comparación, o cuando se trabaja con listas pequeñas donde la simplicidad del algoritmo puede ser más importante que su eficiencia.

\subsection{Clase de complejidad NP}

La clase NP abarca problemas donde una solución afirmativa ("sí") puede ser verificada en tiempo polinomial. En estos problemas, existe un testigo o certificado que sirve como prueba de la validez de la respuesta, y un algoritmo verificador que puede validar este testigo eficientemente.

Un ejemplo clásico es el problema de la suma de subconjuntos: dado un conjunto de $n$ números, se busca si existe un subconjunto cuya suma sea $S$. Para verificar una solución afirmativa, bastaría con que nos dieran el subconjunto en cuestión, y en tiempo lineal podríamos sumar sus elementos para comprobar que la suma es correcta.

Al igual que en P, los problemas en NP pueden incluir aquellos que ya mencionamos, pero con una importante distinción: aunque podemos verificar soluciones en tiempo polinomial, no necesariamente podemos encontrarlas rápidamente. De hecho, uno de los grandes interrogantes en teoría de la complejidad es si todos los problemas en NP pueden ser también resueltos en tiempo polinomial.

\subsubsection{Ejemplo de problema NP: El Problema del Agente Viajero}

El Problema del Agente Viajero es uno de los ejemplos más claros para entender la complejidad NP, dado que es un problema que no se resuelve en tiempo polinomial, buscando encontrar una trayectoria que visita todas las $n$ ciudades exactamente una vez, sin repetir ninguna.

\paragraph{Datos del problema:}
\begin{itemize}
    \item Un entero $n > 0$, que representa el número de ciudades.
    \item Una matriz de distancias $(d_{ij})$ de dimensión $n \times n$, donde $d_{ij}$ es un entero mayor o igual a cero que representa la distancia entre la ciudad $i$ y la ciudad $j$.
\end{itemize}

\paragraph{Representación matemática:}
Una permutación $\pi$ cíclica representa un recorrido, donde $\pi(j)$ se interpreta como la ciudad después de la ciudad $j$, para $j = 1, 2, \ldots, n$.

\paragraph{Costo del recorrido:}
El costo del recorrido se calcula mediante la siguiente fórmula:

\[
\sum_{j=1}^n d_{j,\pi(j)}
\]

Donde:
\begin{itemize}
    \item $j$ recorre todas las ciudades de 1 a $n$
    \item $d_{j,\pi(j)}$ representa la distancia entre la ciudad $j$ y la ciudad que le sigue en el recorrido según la permutación $\pi$
\end{itemize}

\paragraph{Características importantes:}
\begin{enumerate}
    \item La matriz de distancias es simétrica, es decir, $d_{ij} = d_{ji}$ para todo $i, j$.
    \item Las distancias son no negativas: $d_{ij} \geq 0$ para todo $i, j$.
    \item La diagonal de la matriz de distancias $(d_{ii})$ generalmente se define como 0, ya que representa la distancia de una ciudad a sí misma.
\end{enumerate}

\paragraph{Complejidad:}
El Problema del Agente Viajero pertenece a la clase de problemas NP-difícil, lo que significa que no se conoce un algoritmo eficiente (de tiempo polinomial) para resolverlo de manera óptima para todos los casos.

Esta formulación matemática proporciona una base sólida para el análisis y desarrollo de algoritmos que buscan resolver o aproximar soluciones al Problema del Agente Viajero.

\subsection{Reducciones y las clases NP-completo y NP-difícil}

Para profundizar en las clases de NP-completo y NP-difícil, es esencial introducir el concepto de reducción. Una reducción entre problemas significa que si podemos resolver un problema de manera eficiente, entonces también podemos resolver el otro. Esto es clave para entender la relación entre los problemas de estas clases.

\subsubsection{Definición de Reducción Polinomial}

Dado un problema A y un problema B, diremos que existe una reducción polinomial de A a B si cualquier instancia de A puede ser transformada en una instancia de B en tiempo polinomial, de manera que resolver B implica resolver A.

Esto nos lleva a la clase de complejidad NP-difícil, que está compuesta por problemas a los cuales cualquier problema en NP puede ser reducido. NP-completo, por otro lado, incluye aquellos problemas que son tanto NP-difíciles como pertenecientes a NP. Si alguna vez encontráramos un algoritmo eficiente para resolver un problema NP-completo, entonces podríamos resolver todos los problemas en NP de manera eficiente.

\subsection{Conclusión}

Las clases de complejidad P, NP, NP-completo y NP-difícil son fundamentales para comprender la eficiencia de los algoritmos. El problema abierto más importante de la teoría de la computación, P vs NP, sigue siendo una pregunta sin respuesta: ¿Podemos resolver todos los problemas que podemos verificar eficientemente? Resolver esta pregunta tendría implicaciones profundas no solo en la teoría, sino en muchas áreas prácticas de la computación.


\chapter{Desarrollo del proyecto}
%En Este capítulo se incluirán los resultados obtenidos durante el proyecto

\chapter{Conclusiones y trabajo futuro}
%En este capítulo se incluirán las conclusiones y posibles líneas de trabajo que podrían surgir a partir de este proyecto


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% La bibliografía debe aparecer de manera homologada
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{0}
	%\bibitem{}

\end{thebibliography}

\end{document}


