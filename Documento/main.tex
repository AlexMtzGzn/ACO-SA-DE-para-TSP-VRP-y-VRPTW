\documentclass[12pt,titlepage,twoside,openright]{book}

% Codificación y lenguaje
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{tocloft}
\usepackage{tabularx}
\newcommand{\listequationsname}{Índice de fórmulas}
\newlistof{myequations}{eq}{\listequationsname}
\addto\captionsspanish{\renewcommand{\listtablename}{Índice de tablas}}
\addto\captionsspanish{\renewcommand{\listfigurename}{Índice de figuras}}
\addto\captionsspanish{\renewcommand{\listequationsname}{Índice de fórmulas}}


\usepackage{mathpazo}


\usepackage{graphicx}
\usepackage{float}  
\raggedbottom
\usepackage{color}
\usepackage{pstricks, pst-node}
\usepackage{amsfonts, amsmath, amssymb, amsthm} 
\usepackage[linesnumbered,ruled,vlined,algochapter,longend]{algorithm2e}


\usepackage{geometry}
\geometry{
    left=3cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

% Encabezados
\usepackage{fancyhdr}
\setlength{\headheight}{16pt}  
\addtolength{\topmargin}{-1pt} 
\pagestyle{fancy}
\fancyhead{} 
\fancyfoot{} 
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\leftmark}
\fancyhead[LO]{\rightmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}


\usepackage{hyperref}


\usepackage{natbib}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=black,
    pdftitle={VRPTW: Proyecto Terminal},
    pdfauthor={Alejandro Martínez Guzmán}
}


\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else
\hbox{}
\thispagestyle{empty}
\newpage
\if@twocolumn\hbox{}\newpage\fi\fi\fi}
\makeatother

\hyphenation{Colores fa-mi-lia caracte-rizarlos}


\newtheorem{teo}{Teorema}[chapter]
\newtheorem{defi}{Definición}[chapter]
\newtheorem{coro}{Corolario}[chapter]
\newtheorem{lema}{Lema}[chapter]
\newtheorem{prop}{Proposición}[chapter]
\newtheorem{ejemplo}{Ejemplo}[chapter]
\newtheorem{obs}{Observación}[chapter]
\newenvironment{demo}{
  \par\noindent\textbf{Demostración:}\quad
}{
  \hfill$\square$\par
}


\newcommand{\titulo}[1]{\def\eltitulo{#1}}
\newcommand{\carrera}[1]{\def\lacarrera{#1}}
\newcommand{\nombre}[1]{\def\elnombre{#1}}
\newcommand{\director}[1]{\def\eldirector{#1}}
\newcommand{\fecha}[1]{\def\lafecha{#1}}

\titulo{Resolución del Problema de Rutas Vehiculares con Ventanas de Tiempo mediante un Algoritmo Híbrido entre Colonia de Hormigas y Recocido Simulado}
\nombre{\uppercase{Alejandro Martínez Guzmán}}
\carrera{Licenciatura en Ingeniería en Computación}
\director{\uppercase{Edwin Montes Orozco}}
\fecha{Diciembre 2025}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
	\thispagestyle{empty}
	\begin{center}
		{\Large \scshape Universidad Autónoma Metropolitana}\\[0.3cm]
		{\Large \scshape Unidad Cuajimalpa}\\[1cm]

		\includegraphics[width=3.5cm]{Imagenes/uamlogo.png}\\[1cm]

		{\LARGE \textbf{\eltitulo}}\\[1.5cm]

		{\large \textbf{Proyecto Terminal}}\\[1cm]

		\textbf{QUE PRESENTA:}\\[5pt]
		{\large \textbf{\elnombre}}\\[1cm]

		{\large \textsc{\lacarrera}}\\[1cm]

		Departamento de Matemáticas Aplicadas y Sistemas\\[0.8cm]
		División de Ciencias Naturales e Ingeniería\\[1.5cm]

		\textbf{Asesor:} {\eldirector}\\[1cm]

		\vfill
		\begin{flushright}
			\lafecha
		\end{flushright}
	\end{center}
\end{titlepage}
\cleardoublepage




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PÁGINAS PRELIMINARES SIN NÚMERO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frontmatter

\chapter*{Declaración}
\thispagestyle{empty}
Yo, \elnombre, declaro que este trabajo titulado
\textit{«\eltitulo»} es de mi autoría. Asimismo, confirmo que:
\begin{itemize}
	\item Este trabajo fue realizado en su totalidad para la obtención de grado en esta Universidad.
	\item Ninguna parte de esta tesis ha sido previamente sometida a un examen de grado o titulación en esta u otra institución.
	\item Todas las citas han sido debidamente referenciadas y atribuidas a sus autores.
\end{itemize}
\vfill
\begin{flushright}
	Firma: \underline{\hspace{5cm}}\\[0.5cm]
	Fecha: \underline{\hspace{5cm}}
\end{flushright}
\cleardoublepage

\chapter*{Agradecimientos y Dedicatoria}
\begin{flushleft}

	Quisiera comenzar agradeciendo a Dios, por ser mi guía y acompañante en cada etapa de mi vida académica. Su presencia me ha dado fortaleza y sabiduría para superar los retos y alcanzar mis metas. \\

	A la Universidad Autónoma Metropolitana, en especial a la Unidad Cuajimalpa y al Departamento de Matemáticas Aplicadas y Sistemas, por ser una pieza clave en mi formación académica, profesional y personal, sin dejar atrás a cada uno de mis profesores, de quienes siempre guardaré un recuerdo especial. \\

	Al Dr. Edwin Montes Orozco, amigo, profesor y asesor de este proyecto, por su constante apoyo, orientación, paciencia y valiosos consejos durante todo el proceso de investigación y desarrollo. Su conocimiento, experiencia y confianza fueron determinantes para la culminación exitosa de este trabajo, así como su experticia compartida en proyectos de la industria. \\

	A mis padres, Laura y Alejandro, por creer siempre en mí, apoyarme incondicionalmente y enseñarme a confiar en mis capacidades. Su amor, cariño, motivación y consejos constantes han sido el pilar que me sostiene y la inspiración para esforzarme y alcanzar mis metas. \\

	A mi hermana Linda, por su apoyo, compañía y amor incondicional, siempre motivándome y acompañándome en cada etapa de mi vida. \\

	A mis abuelos maternos, Margarita y Salvador, gracias por consentirme, brindarme cariño y enseñanzas que han marcado mi vida desde pequeño. \\

	A mis abuelos paternos, Flor y Trinidad, gracias por su apoyo, ejemplo y cariño constante, que me han acompañado en cada paso de mi formación y crecimiento personal. \\

	A Alpha \\

	A Jaime López, por ser mi gran amigo, por estar siempre dispuesto a ayudar y hacerme sentir que puedo contar con él para lo que sea. \\

	A Sara Hernadez, \\

	A Rebeca López, por recordarme que enseñar también es aprender. \\

	A Alfredo López, \\

	A mi tío Javier Martínez, quien me introdujo al mundo de la computación cuando era niño y a quien considero una fuente de inspiración al elegir esta carrera. \\

	A todos, gracias por ser parte de este gran sueño llamado Ingeniería en Computación. \\

	% Finalmente, quiero agradecer a mis amigos \textbf{Bruno Meneses Fuentes}, por ser mi primer amigo y acompañarme durante toda la carrera; \textbf{Jaime Hilich}, \textbf{Yoshua Valdez} y \textbf{Eduardo González}, por su apoyo, camaradería y motivación en los momentos más difíciles y felices de esta etapa.
\end{flushleft}
\cleardoublepage

\chapter*{Resumen}
\addcontentsline{toc}{chapter}{Resumen}
Aquí va el resumen en español. Este apartado debe sintetizar brevemente el objetivo del trabajo, la metodología empleada y los resultados más relevantes.
\cleardoublepage

\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
Here goes the abstract in English. Briefly describe the goal of your project, methodology, and key results.
\cleardoublepage


\frontmatter
\thispagestyle{empty}

\vspace*{6cm}

\begin{center}
	\textit{"Tu talento es un regalo de Dios para ti. Lo que haces con él es tu regalo de regreso a Dios."}\\[6pt]
	— \textbf{Leo Buscaglia}
\end{center}

\vfill
\cleardoublepage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cftsetindents{subsection}{2em}{3em}
\cftsetindents{subsubsection}{4em}{3em}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\tableofcontents
\cleardoublepage

\listoffigures
\addcontentsline{toc}{chapter}{Índice de Figuras}
\cleardoublepage

\listoftables
\addcontentsline{toc}{chapter}{Índice de Tablas}
\cleardoublepage


\setlength{\cftmyequationsnumwidth}{2.5 em}

\listofmyequations
\addcontentsline{toc}{chapter}{Índice de Fórmulas}
\cleardoublepage

\chapter*{Lista de Abreviaciones}
\addcontentsline{toc}{chapter}{Lista de Abreviaciones}

\vspace{0.5cm}
{\small
\begin{description}[leftmargin=1.8cm, labelwidth=1.5cm, labelsep=0.3cm, itemsep=0.3em]
	\item[ACO] \textbf{A}nt \textbf{C}olony \textbf{O}ptimization (\textit{Optimización por Colonias de Hormigas})
	\item[DE] \textbf{D}ifferential \textbf{E}volution (\textit{Evolución Diferencial})
	\item[EA] \textbf{E}volutionary \textbf{A}lgorithm (\textit{Algoritmo Evolutivo})
	\item[GA] \textbf{G}enetic \textbf{A}lgorithm (\textit{Algoritmo Genético})
	\item[NP] \textbf{N}ondeterministic \textbf{P}olynomial \textbf{T}ime (\textit{Tiempo Polinomial No Determinista})
	\item[P] \textbf{P}olynomial \textbf{T}ime (\textit{Tiempo Polinomial})
	\item[SA] \textbf{S}imulated \textbf{A}nnealing (\textit{Recocido Simulado})
	\item[TB] \textbf{T}abu \textbf{S}earch (\textit{Búsqueda Tabú})
	\item[TSP] \textbf{T}ravelling \textbf{S}alesman \textbf{P}roblem (\textit{Problema del Viajante})
	\item[VRP] \textbf{V}ehicle \textbf{R}outing \textbf{P}roblem (\textit{Problema de Ruteo de Vehículos})
	\item[VRP-TW] \textbf{V}ehicle \textbf{R}outing \textbf{P}roblem with \textbf{T}ime \textbf{W}indows (\textit{Problema de Ruteo de Vehículos con Ventanas de Tiempo})
\end{description}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CUERPO PRINCIPAL (ya numerado)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter
\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO,LE]{\bfseries \thepage}
\fancyhead[LO]{\nouppercase{\rightmark}}
\fancyhead[RE]{\nouppercase{\leftmark}}
\fancyfoot{}

\setlength{\parindent}{2em}
\setlength{\parskip}{1.5ex}

% Reducir espacio extra después de subsubsection

\newcommand{\tab}{\hspace*{1cm}}

\chapter{Introducción}
\label{cap:introduccion}

\section{Planteamiento del Problema}

Dentro de la investigación operativa y la logística, modelos clásicos como el Problema del Agente Viajero (TSP, \emph{Traveling Salesman Problem}) y el Problema de Ruteo de Vehículos (VRP, \emph{Vehicle Routing Problem}) constituyen la base para entender y abordar problemáticas logísticas reales. Sin embargo, en entornos modernos donde existen restricciones temporales estrictas para la atención de clientes, se requieren modelos más complejos, como el Problema de Ruteo de Vehículos con Ventanas de Tiempo (VRP-TW, \emph{Vehicle Routing Problem with Time Windows}).

El VRP-TW consiste en planificar rutas para una flota de vehículos de manera que se minimice el costo total (distancia, tiempo o recursos), asegurando que cada cliente sea atendido dentro de un intervalo de tiempo predefinido y sin violar las capacidades de los vehículos. Este problema pertenece a la clase NP-difícil y presenta una alta complejidad combinatoria, lo que hace inviable su resolución mediante algoritmos exactos para instancias de gran tamaño.

\sloppy
En este contexto, las metaheurísticas se presentan como una alternativa eficaz para obtener soluciones de buena calidad en tiempos razonables. Entre ellas, la Optimización por Colonia de Hormigas (ACO, \emph{Ant Colony Optimization}) ha demostrado ser útil en la construcción de rutas iniciales, mientras que el Recocido Simulado (SA, \emph{Simulated Annealing}), apoyado en diversas heurísticas locales, permite mejorar las soluciones generadas. No obstante, ambos enfoques pueden beneficiarse de mecanismos adicionales de exploración y explotación del espacio de búsqueda; por ello, se propone incorporar el Algoritmo Evolutivo Diferencial (DE, \emph{Differential Evolution}) como componente global de refinamiento.

El problema a resolver, por tanto, se centra en diseñar e implementar un algoritmo híbrido que combine de manera coordinada y efectiva ACO, SA y DE. En este esquema, el DE se emplea para calibrar los parámetros de los otros métodos, permitiendo abordar el VRP-TW a partir de modelos más simples como el TSP y el VRP, considerando tanto la calidad de la solución como su robustez y eficiencia computacional.

\section{Justificación}

El VRP-TW es un problema fundamental en la logística moderna, con aplicaciones directas en la optimización de rutas de distribución y transporte, lo que impacta significativamente en la reducción de costos operativos y la mejora del servicio al cliente. Sin embargo, debido a su complejidad combinatoria y a su pertenencia a la clase NP-difícil, las técnicas exactas resultan impracticables para resolver instancias de tamaño realista.

Las soluciones basadas en metaheurísticas han demostrado ser una alternativa eficiente; sin embargo, la mayoría de los enfoques existentes se centran en una sola técnica, lo que limita la exploración y explotación del espacio de soluciones. La integración de métodos híbridos, como la combinación de ACO, SA y DE, puede potenciar las capacidades de búsqueda y refinamiento, mejorando la calidad y robustez de las soluciones obtenidas.

Este trabajo se justifica en la necesidad de desarrollar un método que aporte mayor eficiencia y calidad para resolver el VRP-TW, utilizando instancias clásicas ampliamente reconocidas en la literatura, como son las propuestas por Solomon, y así contribuir al avance de las técnicas metaheurísticas aplicadas en problemas logísticos complejos.
\section{Objetivos}

\subsection{Objetivo General}


Diseñar, implementar, probar y evaluar un algoritmo híbrido que combine la ACO, el SA con múltiples heurísticas locales y el DE, con el objetivo de resolver de manera eficiente el VRP-TW.

\subsection{Objetivos Específicos}

\begin{enumerate}
	\item Estudiar y analizar los problemas TSP, VRP y VRP-TW para identificar sus similitudes estructurales y diferencias, estableciendo así una base conceptual que permita abordar de forma progresiva el problema principal VRP-TW.

	\item Diseñar un algoritmo híbrido que combine el ACO para la construcción de soluciones iniciales y el SA para la mejora de dichas soluciones, integrando el DE como un componente de autoajuste de parámetros o como mecanismo para generar configuraciones óptimas que guíen el comportamiento de las otras metaheurísticas.

	\item Evaluar el rendimiento del algoritmo híbrido en términos de calidad de la solución y eficiencia computacional, utilizando instancias de prueba estándar aceptadas en la literatura, y comparando los resultados con enfoques clásicos y metaheurísticos individuales.
\end{enumerate}

\section{Alcances y Limitaciones}

\subsection*{Alcances}

\begin{itemize}
	\item El trabajo se centra en la resolución del problema VRP-TW.

	\item Se desarrolla un enfoque híbrido que integra tres técnicas metaheurísticas: ACO, SA y un DE, aplicadas de manera complementaria.

	\item El enfoque es probado con instancias clásicas propuestas por Solomon, ampliamente reconocidas en la literatura, lo que permite una validación objetiva y reproducible de los resultados obtenidos.

	\item Se analizan métricas relevantes como la calidad de la solución, el tiempo de ejecución y la estabilidad del algoritmo ante múltiples ejecuciones.
\end{itemize}

\subsection*{Limitaciones}

\begin{itemize}
	\item El enfoque propuesto está diseñado para instancias estáticas de los problemas de ruteo; no se contempla el tratamiento de versiones dinámicas o en tiempo real.

	\item La calidad de los resultados depende en gran medida de la correcta calibración de los parámetros de ACO y SA; sin embargo, esta calibración no se realiza manualmente, sino que es llevada a cabo automáticamente por el DE.

	\item No se consideran restricciones adicionales como múltiples depósitos, flotas heterogéneas o prioridades diferenciadas entre clientes.

	\item Las pruebas están limitadas a conjuntos de datos artificiales y benchmarks académicos, sin validación en entornos productivos reales.

	\item Al tratarse de métodos metaheurísticos, no se garantiza la obtención del óptimo global, sino soluciones cercanas al óptimo dentro de un tiempo razonable.
\end{itemize}

\section{Estructura del Documento}

La estructura del presente documento se ha diseñado con el propósito de facilitar la comprensión del desarrollo y los resultados obtenidos en esta investigación. El contenido se organiza en cinco capítulos, los cuales se describen a continuación:

En el Capítulo 1 se presenta la introducción del trabajo. Aquí se aborda el planteamiento del problema, la justificación, los objetivos general y específicos, así como los alcances y limitaciones. Este capítulo establece el contexto y la motivación que guían el desarrollo de la investigación.

En el Capítulo 2 se desarrolla el marco teórico y el estado del arte. Se presentan los antecedentes del estudio, incluyendo la evolución histórica de las técnicas de optimización aplicadas a problemas de ruteo. Asimismo, se exponen los conceptos clave en optimización, la complejidad computacional y las clases de problemas P y NP. Se revisan también los principales problemas de optimización combinatoria, como el TSP, el VRP y el VRP-TW, junto con los métodos de solución empleados en la literatura: técnicas exactas, heurísticas, metaheurísticas y enfoques híbridos que han demostrado ser eficientes en la resolución del VRP-TW. Finalmente, se integran referencias relevantes provenientes de trabajos recientes y clásicos, las cuales sirven como base para sustentar teóricamente la propuesta desarrollada en esta investigación.

El Capítulo 3 describe los materiales y métodos utilizados en la investigación. Aquí se detallan las instancias del problema, el software y hardware empleados, así como las herramientas de apoyo. Además, se expone la propuesta híbrida desarrollada, que integra los algoritmos de Evolución Diferencial (DE), Optimización por Colonia de Hormigas (ACO) y Recocido Simulado (SA). Se presentan las metodologías aplicadas, la calibración de parámetros, la construcción de rutas y el proceso de refinamiento, junto con sus respectivos pseudocódigos.

El Capítulo 4 presenta los resultados experimentales obtenidos a partir de la implementación del algoritmo híbrido desarrollado. Se describe la calidad de las soluciones generadas y el comportamiento del proceso de búsqueda bajo distintas configuraciones de parámetros. Aunque no se realizó una comparación directa con otros algoritmos mediante experimentación propia, se incluyen referencias a resultados reportados en la literatura, lo cual permite contextualizar el rendimiento del enfoque propuesto.

Finalmente, en el Capítulo 5 se presentan las conclusiones generales del estudio, así como posibles líneas de investigación futura que surgen a partir del trabajo realizado.

\chapter{Marco Teórico / Estado del Arte}
\label{cap:marco-teorico}
\section{Antecedentes}

El estudio de problemas de optimización en rutas se remonta al desarrollo del Problema del Agente Viajero (TSP), formulado a principios del siglo XX, cuyo objetivo es encontrar la ruta de costo mínimo que recorra un conjunto de ciudades exactamente una vez, regresando al punto de partida. A lo largo de las décadas, este problema se ha consolidado como uno de los pilares de la optimización combinatoria \citep{papadimitriou1994}.

Más adelante, se propuso el Problema de Ruteo de Vehículos (VRP) como una generalización del TSP, considerando una flota de vehículos que deben atender a múltiples clientes desde un depósito central. Este problema fue introducido por primera vez por Dantzig y Ramser en 1959 para optimizar rutas de distribución de gasolina \citep{dantzig1959truck}.

Durante la década de 1970, el interés por resolver variantes del VRP aumentó significativamente, y surgieron métodos heurísticos como el algoritmo de Clarke y Wright (1964), que se convirtió en un referente para aproximaciones iniciales \citep{clarke1964scheduling}.

Entre la década de 1970 y la de 1980, se desarrollaron versiones especializadas como el \textit{Fleet Routing Problem}, sistemas \textit{Dial-a-Bus} y el diseño de redes de transporte, así como enfoques probabilísticos y la incorporación de incertidumbre \citep{eksioglu2009, golden1988, laporte1992}.

Dentro de estas variantes, el Problema de Ruteo de Vehículos con Ventanas de Tiempo (VRP-TW) surgió como una extensión crítica que incorpora restricciones temporales para reflejar mejor las condiciones reales de operación, tales como horarios de entrega y recogida. Este problema fue estudiado ampliamente a partir del trabajo de Solomon en 1987, quien introdujo instancias benchmark y algoritmos heurísticos clásicos \citep{solomon1987algorithms}.

Durante la década de 1990, se desarrollaron enfoques exactos basados en programación entera y técnicas como \textit{branch-and-bound}, \textit{branch-and-cut} y \textit{column generation}, aplicados con éxito a instancias pequeñas \citep{desrochers1992, cordeau2002}. Sin embargo, la elevada complejidad del VRP-TW motivó el uso creciente de heurísticas y metaheurísticas, tales como:

\begin{itemize}
	\item \textbf{Algoritmos Genéticos (GA)}, inspirados en la evolución natural, propuestos por Holland en 1975, que utilizan operadores genéticos para evolucionar una población de soluciones \citep{holland1975adaptation}.
	\item \textbf{Algoritmo de Colonias de Hormigas (ACO)}, propuesto inicialmente por Dorigo en 1992, basado en el comportamiento colectivo de las hormigas para resolver problemas combinatorios \citep{dorigo1992}.
	\item \textbf{Recocido Simulado (SA)}, inspirado en el proceso físico de enfriamiento de metales, introducido por Kirkpatrick, Gelatt y Vecchi en 1983, que permite escapar de óptimos locales mediante la aceptación controlada de soluciones peores \citep{kirkpatrick1983}.
	\item \textbf{Búsqueda Tabú (TB)}, una técnica heurística que explora iterativamente soluciones vecinas para mejorar la calidad de la solución, evitando ciclos mediante la prohibición temporal de movimientos \citep{aarts1988local}.
\end{itemize}

Estas metaheurísticas han demostrado ser eficaces para obtener soluciones cercanas al óptimo en tiempos razonables \citep{eksioglu2009}.

En las últimas dos décadas, la investigación se ha enfocado en algoritmos híbridos, técnicas de aprendizaje automático aplicadas al VRP, optimización robusta y modelos dinámicos, buscando mejorar la eficiencia y adaptabilidad de las soluciones en contextos logísticos cada vez más complejos y cambiantes \citep{toth2014}.

El presente trabajo se inscribe en esta línea de investigación, proponiendo un modelo basado en un algoritmo híbrido con metaheurísticas para abordar el VRP-TW, considerando específicamente restricciones operativas como la capacidad limitada de los vehículos y los intervalos estrictos de tiempo de servicio asignados a cada cliente. Con el objetivo de mejorar la calidad y eficiencia de las rutas generadas, se implementaron tres enfoques metaheurísticos: el Algoritmo Evolutivo Diferencial (DE), el Algoritmo de Optimización por Colonias de Hormigas (ACO) y el Recocido Simulado (SA).

\section{Conceptos Clave}

\subsection{El Problema en Optimización}

Los problemas de optimización constituyen una herramienta fundamental en ciencias computacionales, ingeniería, logística y muchas otras disciplinas. En el contexto de este trabajo de investigación, resultan especialmente relevantes porque permiten modelar situaciones en las que se busca obtener el mejor resultado posible bajo ciertas restricciones, como minimizar costos, distancias o tiempos.

De acuerdo con \citep{cobos2010}, los problemas de optimización se dividen de manera natural en dos categorías: problemas con variables continuas y problemas con variables discretas. A estos últimos se les conoce como problemas de optimización combinatoria.

La función \(f : S \to \mathbb{R}\), donde el conjunto \(S\) es un subconjunto de \(\mathbb{R}^n\), se denomina función objetivo, función de costo beneficio, mientras que el conjunto \(S\) se identifica como el conjunto factible o el conjunto de soluciones posibles \citep{cobos2010}.

Como definición formal, se puede decir que el problema general de optimización consiste en encontrar un elemento \(x \in S\) que optimice la función objetivo. En el caso de un problema de minimización, se expresa de la siguiente manera:

\[
	\min_{x \in S} f(x).
\]

Por su parte, en un problema de maximización, se utiliza la notación:

\[
	\max_{x \in S} f(x).
\]

\citep{cobos2010}



\subsubsection{Optimización Continua}

En la optimización continua para problemas de minimización, el objetivo es encontrar un punto \( x_{opt} \) dentro del conjunto factible \( S \) tal que el valor de la función objetivo en ese punto sea menor o igual que el valor en cualquier otro punto del conjunto, es decir,

\[
	f(x_{opt}) \leq f(x), \quad \forall x \in S.
\]

Para problemas de maximización, se busca un punto \( x_{opt} \) en \( S \) donde la función objetivo tome un valor mayor o igual al de cualquier otro punto factible, esto es,

\[
	f(x_{opt}) \geq f(x), \quad \forall x \in S.
\]

A este punto se le denomina solución óptima global, y el valor correspondiente \( f(x_{opt}) \) se conoce como costo óptimo. Además, el conjunto de todas las soluciones óptimas se representa por \( S_{opt} \) \citep{cobos2010}.


\subsubsection{Optimización Discreta o Combinatoria}
\label{subsec:opt_discreta}

Una instancia de un problema de optimización combinatoria puede representarse mediante una pareja \((S, f)\), donde \(S\) es un conjunto finito que contiene todas las soluciones posibles, y \(f\) es una función real, denominada función objetivo o función costo, definida como

\[
	f: S \to \mathbb{R}.
\]

Para problemas de minimización, se busca una solución \(i_{opt} \in S\) tal que

\[
	f(i_{opt}) \leq f(i), \quad \forall i \in S,
\]

mientras que para problemas de maximización, se requiere que

\[
	f(i_{opt}) \geq f(i), \quad \forall i \in S.
\]

La solución \(i_{opt}\) se denomina solución óptima global, y el valor \(f(i_{opt})\) representa el costo óptimo. El conjunto de todas las soluciones óptimas se denota como \(S_{opt}\). Un problema de optimización combinatoria se define entonces como el conjunto de todas sus instancias \citep{cobos2010}.

Comprender esta distinción es esencial para abordar el problema central de este trabajo VRP-TW, el cual se enmarca dentro de la optimización combinatoria. En este tipo de problemas, el número de soluciones posibles es finito, y el desafío consiste en identificar cuál de ellas representa la mejor opción según un criterio específico.

Esta base teórica permite introducir los problemas clásicos de enrutamiento, como el TSP, el VRP y sus variantes, como el VRP-TW, los cuales serán analizados más adelante por su relación directa con la planificación eficiente de rutas en contextos reales.

\subsection{Complejidad Computacional y Algorítmica}

El estudio de la complejidad en ciencias computacionales busca comprender qué tan difícil es resolver un problema, tanto desde su estructura teórica como desde los recursos requeridos para su solución. Esta dificultad se aborda desde dos enfoques: la complejidad computacional, que clasifica los problemas según el crecimiento de recursos necesarios en función del tamaño de la entrada, y la complejidad algorítmica, que evalúa el desempeño de algoritmos específicos al aplicarse sobre dichas entradas \citep{garey1979computers, papadimitriou1994}.

De forma simplificada, la complejidad computacional se refiere al análisis general del problema sin importar el algoritmo, mientras que la algorítmica se enfoca en el tiempo y espacio consumido por un algoritmo concreto \citep{maldonado2013problema}.

Esta distinción es clave al abordar problemas de optimización combinatoria como el TSP, el VRP y su variante principal en este trabajo: el VRP-TW, que presentan una explosión combinatoria (crecimiento factorial) de soluciones conforme crece el número de clientes.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/grafico-complejidad-computacionala3.png}
	\caption{Tasa de crecimiento de varias funciones en análisis de algoritmos \cite{numerentur2019}.}
	\label{fig:figura_complejidad_computacional}
\end{figure}

En la Figura~\ref{fig:figura_complejidad_computacional} se observa cómo las funciones constantes $\mathcal{O}(1)$ y logarítmicas $\mathcal{O}(\log n)$ crecen lentamente, incluso para entradas de gran tamaño. Las funciones polinomiales, como $\mathcal{O}(n)$ y $\mathcal{O}(n \log n)$, presentan un crecimiento más acelerado pero aún manejable. En contraste, las funciones exponenciales $\mathcal{O}(2^n)$ y factoriales $\mathcal{O}(n!)$ crecen de manera extremadamente rápida, lo que vuelve intratables los problemas asociados a medida que aumenta el tamaño de la entrada. Por esta razón, problemas como el TSP, VRP y VRP-TW se consideran de alta complejidad computacional, ya que su espacio de búsqueda crece factorialmente.
\subsection{El Problema P vs NP}

En ciencias de la computación, todos los problemas pueden clasificarse en dos grupos principales: problemas decidibles y problemas indecidibles. Un problema es \emph{indecidible} cuando no existe ningún algoritmo que pueda resolverlo, incluso si se dispone de tiempo y recursos ilimitados. En consecuencia, no es posible determinar si dicho problema terminará su ejecución. Por contraste, un problema es \emph{decidible} cuando existe (o podría existir) un algoritmo capaz de resolverlo \citep{maldonado2013problema}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/Diagrama.pdf}
	\caption{Clasificación de los problemas computacionales en decidibles e indecidibles~\citep{maldonado2013problema}.}
	\label{fig:decidibilidad}
\end{figure}

En este trabajo, los problemas abordados —el TSP, el VRP y el VRP-TW— son considerados problemas decidibles. A continuación, se presenta una clasificación más detallada dentro de esta categoría, basada en la teoría de la complejidad computacional.

% [Sigue tu sección de Clases P y NP...]

\subsubsection{Clases P y NP}

Dentro de los problemas decidibles, las clases P y NP juegan un papel fundamental \citep{maldonado2013problema}.

\subsubsection*{Clase P}
Un problema pertenece a la clase P si puede resolverse mediante un algoritmo cuyo tiempo de ejecución está acotado por una función polinomial respecto al tamaño de la entrada. Formalmente, existe un polinomio \(p(n)\) y constantes \(\alpha, n_0 > 0\) tales que:

\[
	D(n) \leq \alpha \cdot p(n) \quad \forall n \geq n_0,
\]

lo que se expresa en notación asintótica como

\[
	D = O(n^k).
\]

Aunque se considera que algoritmos con tiempo polinomial son “eficientes”, en la práctica el grado del polinomio importa, ya que un polinomio de grado muy alto puede ser inviable. Un ejemplo clásico de problema en P es la multiplicación de números naturales \citep{Flores2014}.

\subsubsection*{Clase NP}
\label{subsec: clase_np}
Un problema pertenece a la clase NP si, dado un candidato a solución certificado, es posible verificar su validez en tiempo polinomial. Es importante notar que esto no implica necesariamente que exista un algoritmo eficiente para encontrar la solución, sino que su validación es eficiente. Un ejemplo típico es el TSP: si se proporciona una ruta candidata, es fácil comprobar en tiempo polinomial la longitud total de la ruta para verificar si cumple cierta condición \citep{Flores2014}.

\subsubsection*{La gran incógnita: ¿P = NP?}
Una de las preguntas abiertas más importantes en ciencias de la computación es si \(\mathbf{P = NP}\) o \(\mathbf{P \neq NP}\), es decir, si todo problema cuya solución puede verificarse rápidamente también puede resolverse rápidamente. Esta cuestión tiene profundas implicaciones teóricas y prácticas \citep{maldonado2013problema}.

\subsubsection{NP-Completo y NP-Difícil}

Dentro de la clase NP existe una subclase de problemas llamados NP-completos, que son los problemas más difíciles en NP. Si se encontrara un algoritmo eficiente para cualquiera de ellos, entonces todos los problemas en NP podrían resolverse eficientemente \citep{maldonado2013problema}.

Por otro lado, los problemas NP-difíciles pueden ser incluso más complejos que los NP-completos, ya que no requieren pertenecer a NP (es decir, su solución no tiene por qué ser verificable en tiempo polinomial), pero son al menos tan difíciles como los problemas NP-completos. Pueden incluir problemas de decisión, búsqueda u optimización \citep{maldonado2013problema}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/P_vs_NP.pdf}
	\caption{Relación entre las clases de complejidad: P, NP, NP-completo y NP-difícil.}
	\label{fig:p_vs_np}
\end{figure}

El crecimiento exponencial del tiempo requerido para resolver problemas como el TSP, el VRP y el VRP-TW los ubica dentro de la clase NP. Estos problemas, aunque decidibles, presentan una complejidad tan elevada que no se conoce ningún algoritmo exacto que los resuelva eficientemente para instancias grandes. Por ello, más adelante se analizará su clasificación específica dentro de NP, así como las estrategias metaheurísticas empleadas para aproximar soluciones en tiempos razonables.

\subsection{Problemas de Optimización Combinatoria}

De manera complementaria a la definición formal presentada en la sección~\ref{subsec:opt_discreta}, Papadimitriou y Steiglitz \citep{papadimitriou1998} definen la optimización combinatoria como el estudio de problemas de optimización en los que el conjunto de soluciones factibles es discreto, o puede discretizarse mediante un proceso de enumeración, y donde se busca una solución que optimice una función objetivo definida sobre dicho conjunto.

Los problemas de optimización combinatoria constituyen una clase amplia de modelos aplicables a diversas áreas, especialmente en la planificación y el enrutamiento de vehículos. Dentro de este campo destacan el TSP, que representa la forma más básica de optimización de rutas, y sus extensiones, que incorporan restricciones adicionales propias de escenarios reales, como la capacidad limitada de los vehículos o las ventanas de tiempo en las que deben realizarse las entregas.

En este contexto, el VRP y el VRP-TW se han consolidado como dos de los desafíos más estudiados, debido a su relevancia práctica y su elevada complejidad computacional. A continuación, se describen estos problemas en detalle.
\subsubsection{Problema del Agente Viajero (TSP)}
\label{subsec:problem_tsp}

El Problema del Agente Viajero, conocido por sus siglas en inglés como TSP (\emph{Travelling Salesman Problem}), es uno de los problemas más reconocidos y complejos dentro de las ciencias computacionales. Ha sido estudiado desde diversas ramas de la ingeniería y por múltiples motivos. Su aplicación principal consiste en determinar rutas desde diferentes enfoques, ya sea en procesos que requieren una secuencia específica o en operaciones logísticas relacionadas con el transporte, con el objetivo de encontrar la ruta óptima considerando criterios de minimización de distancia o de costo \citep{lopez2014tabu}.

En la Figura~\ref{fig:tsp} se presenta una representación gráfica de una posible solución al TSP. En ella, un vehículo parte de un nodo inicial(depósito), recorre una serie de ciudades o puntos de entrega siguiendo una secuencia determinada, y regresa al punto de partida, completando así un circuito cerrado que minimiza la distancia total recorrida.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/TSP.pdf}
	\caption{Ejemplificación de una solución al Problema del Agente Viajero (TSP).}
	\label{fig:tsp}
\end{figure}



Según \citep{torres2018}, el TSP se define sobre un grafo \(G = [N,A,C]\), donde \(N\) es el conjunto de nodos, \(A\) es el conjunto de arcos y \(C = [c_{ij}]\) es la matriz de costos (distancias) entre nodos \(i\) y \(j\). El objetivo es encontrar un ciclo hamiltoniano de costo mínimo que recorra todos los nodos una sola vez y regrese al punto de partida.

\subsubsection*{Modelo Matemático del Problema del Agente Viajero (TSP)}

\begin{equation}
	\min \sum_{i=1}^N \sum_{j=1}^N c_{ij}\,x_{ij}
	\label{eq:TSP_obj}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Función objetivo TSP: minimizar el costo total del recorrido}

sujeto a:

\begin{equation}
	\sum_{j=1}^N x_{ij} = 1, \quad \forall i = 1,\dots,N
	\label{eq:TSP_out}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Restricción de salida única de cada nodo}

\begin{equation}
	\sum_{i=1}^N x_{ij} = 1, \quad \forall j = 1,\dots,N
	\label{eq:TSP_in}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Restricción de entrada única a cada nodo}

\begin{equation}
	u_i - u_j + N x_{ij} \leq N - 1, \quad \forall i,j = 2,\dots,N, \; i \neq j
	\label{eq:TSP_subtour}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Restricción de eliminación de subciclos}

\begin{equation}
	x_{ij} \in \{0,1\}, \quad \forall i,j = 1,\dots,N
	\label{eq:TSP_bin}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Variables binarias que indican si la ruta va de \(i\) a \(j\)}

\medskip

\noindent donde:
\begin{itemize}
	\item \(x_{ij} = 1\) si la ruta va de \(i\) a \(j\), y 0 en caso contrario;
	\item \(u_i\) son variables auxiliares usadas para eliminar subciclos, con \(i=2,\dots,N\) \citep{torres2018}.
\end{itemize}

La función objetivo~\eqref{eq:TSP_obj} representa la suma total de los costos (o distancias) de los arcos que conforman el recorrido. La restricción en~\eqref{eq:TSP_out} garantizan que, al salir de cada nodo, sólo se dirija a un único nodo siguiente. La restricción en~\eqref{eq:TSP_in} aseguran que a cada nodo únicamente se llegue una vez. La restricción~\eqref{eq:TSP_subtour} es fundamental, ya que previene la formación de subciclos que no incluyan a todos los nodos, asegurando así un recorrido único y completo.Finalmente, la restricción~\eqref{eq:TSP_bin} indica que las variables \(x_{ij}\) son binarias, es decir, sólo pueden tomar los valores 0 o 1, lo que permite representar la inclusión o exclusión de una ruta entre nodos \citep{torres2018}.

\subsubsection*{Complejidad del TSP}

Como explica \cite{papadimitriou1998}, el TSP es NP-difícil, y su versión de decisión es NP-completa. Esto implica que la búsqueda de un algoritmo eficiente para resolverlo representa un desafío fundamental en la teoría de la computación, pues encontrar una solución polinomial para el TSP permitiría resolver eficientemente toda la clase \textit{NP}. Esta dificultad justifica la utilización de algoritmos heurísticos y metaheurísticos, dado que las técnicas exactas sólo resultan prácticas para instancias

El TSP ha sido tradicionalmente considerado como el punto de partida para el estudio de problemas más complejos de enrutamiento, como el VRP y sus variantes, entre ellas el  VRP-TW. Su análisis proporciona una base conceptual sólida para comprender aspectos fundamentales como la construcción de rutas, la minimización de costos y el manejo de restricciones operativas. Estudiar el TSP permite introducir de forma gradual nuevas variables y condiciones, lo que lo convierte en un modelo introductorio ideal para el desarrollo de enfoques logísticos más realistas.

\subsubsection{Problema del Problema Ruteo de Vehículos (VRP)}
\label{subsec:problem_vrp}

El Problema del Ruteo de Vehículos, conocido por sus siglas en inglés como VRP (\emph{Vehicle Routing Problem}), puede interpretarse como la convergencia de dos problemas clásicos de optimización combinatoria: el Problema del Agente Viajero (TSP) mencionado anteriormene en la sección~\ref{subsec:problem_tsp}, en el que se asume una capacidad infinita de los vehículos, y el Problema de Empaquetamiento en Compartimentos (BPP) \cite{daza2009}. En su formulación más básica, el VRP considera un depósito central desde donde parte una flota de vehículos para atender a un conjunto de clientes distribuidos geográficamente. Cada vehículo debe visitar un subconjunto de clientes exactamente una vez, respetando su capacidad de carga y satisfaciendo la demanda de los clientes asignados. El objetivo es minimizar el costo total asociado a las rutas, las cuales inician y finalizan en el depósito \cite{montes2017}.

La Figura~\ref{fig:vrp} muestra una representación gráfica de una solución al VRP. En este ejemplo, varios vehículos parten desde un depósito central para atender a distintos clientes distribuidos geográficamente. Cada ruta ha sido asignada de manera que se respeten las restricciones de capacidad de carga de los vehículos, y se minimice la distancia total recorrida, cumpliendo así con los objetivos del problema.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/VRP.pdf}
	\caption{Ejemplificación de una solución al Problema de Ruteo de Vehículos (VRP).}
	\label{fig:vrp}
\end{figure}

Según \citep{toth2014}, el VRP  se define sobre un grafo $G = (V, A)$, donde $V = \{0, 1, \dots, n\}$ representa el conjunto de nodos, con el nodo $0$ correspondiente al depósito y los nodos restantes a los clientes, $A$ es el conjunto de arcos, y $C = [c_{ij}]$ es la matriz de costos asociados a los arcos $(i, j)$. El objetivo es determinar un conjunto de rutas de costo mínimo para una flota de vehículos idénticos, de modo que: cada cliente sea visitado exactamente una vez por un solo vehículo, cada ruta comience y termine en el depósito, y la demanda total de los clientes en cada ruta no exceda la capacidad del vehículo.

\subsubsection*{Modelo Matemático del Problema de Ruteo de Vehículos (VRP)}

\begin{equation}
	\min \sum_{i \in V} \sum_{j \in V} c_{ij} x_{ij}
	\label{eq:VRP_obj}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Función objetivo VRP: minimizar el costo total del recorrido}

sujeto a:

\begin{equation}
	\sum_{i \in V} x_{ij} = 1, \quad \forall j \in V \setminus \{0\}
	\label{eq:VRP_in}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Restricción: entrada única a cada cliente}

\begin{equation}
	\sum_{j \in V} x_{ij} = 1, \quad \forall i \in V \setminus \{0\}
	\label{eq:VRP_out}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Restricción: salida única desde cada cliente}

\begin{equation}
	\sum_{i \in V} x_{i0} = K
	\label{eq:VRP_into_depot}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation}Restricción: número de vehículos que regresan al depósito}

\begin{equation}
	\sum_{j \in V} x_{0j} = K
	\label{eq:VRP_from_depot}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: número de vehículos que salen del depósito}

\begin{equation}
	\sum_{i \in S} \sum_{j \in S} x_{ij} \geq r(S), \quad \forall S \subseteq V \setminus \{0\},\; S \neq \emptyset
	\label{eq:VRP_subtour}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción de conectividad: eliminación de subrutas}

\begin{equation}
	x_{ij} \in \{0, 1\}, \quad \forall i,j \in V
	\label{eq:VRP_bin}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Variables binarias: decisión de ruta entre nodos}
\medskip

\noindent donde:
\begin{itemize}
	\item \(V\) es el conjunto de nodos (clientes más depósito), con el depósito representado por el nodo 0;
	\item \(c_{ij}\) es el costo (o distancia) de viajar del nodo \(i\) al nodo \(j\);
	\item \(x_{ij} = 1\) si se viaja directamente del nodo \(i\) al nodo \(j\), 0 en otro caso;
	\item \(K\) es el número de vehículos disponibles en el depósito;
	\item \(S\) es un subconjunto de clientes, y \(r(S)\) representa el número mínimo de vehículos necesarios para satisfacer la demanda total de los clientes en \(S\) \citep{toth2014}.
\end{itemize}

La función objetivo~\eqref{eq:VRP_obj} minimiza el costo total de todas las rutas. Las restricciones~\eqref{eq:VRP_in} y~\eqref{eq:VRP_out} aseguran que cada cliente sea visitado exactamente una vez. Las restricciones~\eqref{eq:VRP_into_depot} y~\eqref{eq:VRP_from_depot} controlan el número de vehículos que entran y salen del depósito. La restricción~\eqref{eq:VRP_subtour} evita la formación de subrutas que no incluyan al depósito, garantizando conectividad. Finalmente, la restricción~\eqref{eq:VRP_bin} indica que las variables de decisión son binarias \citep{toth2014}.


\subsubsection*{Complejidad del VRP}
\label{subsec:complejidad_vrp}

Como señalan Laporte y Nobert \cite{laporte1987}, el VRP es NP-difícil, incluso en su versión más simple con un solo vehículo (es decir, el TSP). Esto significa que no se conoce ningún algoritmo que lo resuelva de forma exacta en tiempo polinomial, y su complejidad crece exponencialmente con el número de clientes. Por ello, la mayoría de las instancias prácticas requieren el uso de técnicas heurísticas o metaheurísticas, ya que los métodos exactos son computacionalmente inviables para problemas de tamaño medio o grande.

El VRP representa la extensión natural del TSP hacia escenarios logísticos más realistas y complejos, incorporando restricciones operativas que reflejan las limitaciones del mundo real. Su estudio es fundamental para comprender cómo las restricciones de capacidad, múltiples vehículos y la gestión de flotas impactan en la optimización de rutas. El VRP sirve como base conceptual para abordar problemas logísticos avanzados como la distribución con ventanas de tiempo, el ruteo con múltiples depósitos y la optimización de última milla en el comercio electrónico. Analizar el VRP permite desarrollar una comprensión profunda de los compromisos inherentes entre la minimización de costos, la utilización eficiente de recursos y la satisfacción de restricciones operativas, estableciendo los fundamentos teóricos necesarios para abordar las complejidades de los sistemas de distribución modernos.

\subsubsection{Problema de Ruteo de Vehículos con Ventanas de Tiempo (VRP-TW)}
\label{subsec:problem_vrptw}

El Problema de Ruteo de Vehículos con Ventanas de Tiempo, conocido por sus siglas en inglés como VRP-TW (\textit{Vehicle Routing Problem with Time Windows}), es una extensión del clásico VRP mencionado anteriormene en la sección~\ref{subsec:problem_vrp} que incorpora restricciones temporales. En este problema, además de satisfacer las demandas específicas de cada cliente, es imprescindible que las visitas se realicen dentro de una franja horaria determinada para cada uno de ellos \citep{toth2014}. Específicamente, el servicio a un cliente debe comenzar en un instante mayor o igual al inicio de su ventana de tiempo, y el arribo al punto de servicio no puede exceder el límite superior de dicha ventana. Asimismo, en caso de que un vehículo llegue antes del inicio de la ventana, deberá esperar hasta el momento indicado para poder atender al cliente \citep{montes2017}.

En este contexto, el objetivo fundamental del VRP-TW es determinar un conjunto de rutas para una flota de vehículos homogéneos que partan y regresen al depósito, visiten cada cliente exactamente una vez dentro de su respectiva ventana temporal, y sin exceder la capacidad de los vehículos. Todo esto debe lograrse minimizando el costo total del recorrido, usualmente expresado en términos de distancia o tiempo \cite{solomon1987algorithms}.

En la Figura~\ref{fig:vrptw} se muestra una solución típica al VRP-TW. En este caso, las rutas de múltiples vehículos parten desde un único depósito, deben cumplir con las capacidades máximas y además respetar las ventanas temporales de atención en cada cliente, optimizando el recorrido total.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Figuras/VRPTW.pdf}
	\caption{Ejemplificación de una solución al Problema de Ruteo de Vehículos con Ventanas de Tiempo (VRP-TW).}
	\label{fig:vrptw}
\end{figure}

Según \citep{toth2014}, el VRP-TW se define sobre un grafo dirigido \(G = (V, A)\), donde \(V = \{0, 1, \dots, n, n+1\}\) representa el conjunto de nodos, siendo \(0\) y \(n+1\) el depósito (nodos origen y destino, respectivamente), y \(N = V \setminus \{0, n+1\}\) el conjunto de clientes. Cada arco \((i, j) \in A\) tiene asociado un costo \(c_{ij}\) y un tiempo de viaje \(t_{ij}\). Además, cada cliente \(i\) tiene una demanda \(d_i\), un tiempo de servicio \(s_i\), y una ventana de tiempo \([a_i, b_i]\) dentro de la cual debe iniciarse su servicio.


\subsubsection*{Modelo Matemático del Problema de Ruteo de Vehículos con Ventanas de Tiempo (VRP-TW)}

\begin{equation}
	\min \sum_{k \in K} \sum_{i \in V} \sum_{j \in V} c_{ij} x_{ijk}
	\label{eq:VRPTW_obj}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Función objetivo VRPTW: minimizar el costo total del recorrido}

sujeto a:

\begin{equation}
	\sum_{k \in K} \sum_{j \in V} x_{ijk} = 1, \quad \forall i \in N
	\label{eq:VRPTW_visit_once}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: cada cliente es visitado exactamente una vez}

\begin{equation}
	\sum_{j \in V} x_{0jk} = 1, \quad \forall k \in K
	\label{eq:VRPTW_start_depot}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: cada vehículo inicia su ruta en el depósito}

\begin{equation}
	\sum_{i \in V} x_{i,n+1,k} = 1, \quad \forall k \in K
	\label{eq:VRPTW_end_depot}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: cada vehículo termina su ruta en el depósito}

\begin{equation}
	\sum_{j \in V} x_{ijk} - \sum_{j \in V} x_{jik} = 0, \quad \forall k \in K, \forall i \in N
	\label{eq:VRPTW_flow_balance}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: conservación de flujo para cada vehículo y cliente}

\begin{equation}
	w_{jk} \geq w_{ik} + s_i + t_{ij} - M (1 - x_{ijk}), \quad \forall k \in K, \forall i,j \in V
	\label{eq:VRPTW_time_window}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: respeto a la ventana de tiempo y orden de servicio}

\begin{equation}
	a_i \leq w_{ik} \leq b_i, \quad \forall k \in K, \forall i \in V
	\label{eq:VRPTW_time_bounds}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: inicio del servicio dentro de la ventana de tiempo}

\begin{equation}
	\sum_{i \in V} \sum_{j \in V} d_i x_{ijk} \leq C, \quad \forall k \in K
	\label{eq:VRPTW_capacity}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Restricción: capacidad máxima del vehículo}

\begin{equation}
	x_{ijk} \in \{0, 1\}, \quad w_{ik} \geq 0, \quad \forall k \in K, \forall i,j \in V
	\label{eq:VRPTW_bin}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Variables binarias y tiempos no negativos}

\medskip
\noindent donde:
\begin{itemize}
	\item \(V = \{0, 1, \ldots, n, n+1\}\) es el conjunto de nodos, donde \(0\) y \(n+1\) representan el depósito;
	\item \(N = V \setminus \{0, n+1\}\) es el conjunto de clientes;
	\item \(K\) es el conjunto de vehículos disponibles;
	\item \(A\) es el conjunto de arcos permitidos entre nodos;
	\item \(c_{ij}\) es el costo o distancia de viajar del nodo \(i\) al nodo \(j\);
	\item \(x_{ijk}\) es variable binaria que indica si el vehículo \(k\) viaja directamente del nodo \(i\) al nodo \(j\);
	\item \(w_{ik}\) es el tiempo de inicio del servicio del vehículo \(k\) en el nodo \(i\);
	\item \(s_i\) es el tiempo de servicio requerido en el nodo \(i\);
	\item \(t_{ij}\) es el tiempo de viaje entre los nodos \(i\) y \(j\);
	\item \([a_i, b_i]\) es la ventana de tiempo para el nodo \(i\);
	\item \(d_i\) es la demanda del cliente \(i\);
	\item \(C\) es la capacidad máxima de cada vehículo;
	\item \(M\) es un número grande usado para activar o desactivar restricciones condicionales.
\end{itemize}

La función objetivo~\eqref{eq:VRPTW_obj} minimiza el costo total de todas las rutas. Las restricciones~\eqref{eq:VRPTW_visit_once} garantizan que cada cliente sea visitado exactamente una vez. Las restricciones~\eqref{eq:VRPTW_start_depot} y \eqref{eq:VRPTW_end_depot} aseguran que cada vehículo comience y termine su ruta en el depósito. La restricción~\eqref{eq:VRPTW_flow_balance} mantiene el balance de flujo para cada vehículo y cliente. La restricción~\eqref{eq:VRPTW_time_window} impone el orden y respeto a las ventanas temporales mediante los tiempos de servicio y de viaje, con ayuda del parámetro \(M\). La restricción~\eqref{eq:VRPTW_time_bounds} asegura que el servicio inicie dentro de la ventana asignada. La restricción~\eqref{eq:VRPTW_capacity} limita la capacidad máxima que puede transportar cada vehículo. Finalmente, la restricción~\eqref{eq:VRPTW_bin} define los dominios de las variables de decisión \citep{toth2014}.

\subsubsection*{Complejidad del VRP-TW}

Sabemos que la complejidad del VRP es NP-difícil, como se señala en la \autoref{subsec:problem_vrp} y en \citep{laporte1987}. El VRP-TW es una generalización del VRP clásico, y también pertenece a la clase de problemas NP-difícil. De hecho, incluso si se ignoran las ventanas de tiempo, el problema sigue siendo difícil de resolver. Al incorporar restricciones temporales, el VRP-TW se vuelve aún más complejo, tanto desde el punto de vista computacional como algorítmico. Según Bräysy y Gendreau \citep{braysy2005} y Toth y Vigo \citep{toth2014}, las ventanas de tiempo reducen significativamente el conjunto de soluciones viables, aumentando así la dificultad del problema.

El VRP-TW representa una evolución del VRP, el cual a su vez deriva del TSP. Estos problemas están orientados a entornos donde las restricciones temporales y operativas son determinantes para la calidad del servicio.

Esta variante refleja de forma más precisa los desafíos logísticos actuales, en los que los clientes no solo deben ser visitados, sino también atendidos dentro de intervalos de tiempo específicos. Esto impone una coordinación precisa entre la planificación de rutas, la gestión de recursos y el cumplimiento de niveles de servicio.

Por ello, resulta fundamental comprender los fundamentos del TSP y del VRP, ya que constituyen la base teórica sobre la cual se desarrolla el VRP-TW, que es el problema principal abordado en este trabajo. A partir de este punto, se profundizará en las técnicas y metodologías empleadas para resolver dicha variante.


\subsection{Métodos de Solución para el VRP-TW}
Los problemas de enrutamiento como el TSP, el VRP y su extensión con ventanas de tiempo, el VRP-TW, mencionados en secciones anteriores, pertenecen a la clase de problemas NP-difíciles \citep{papadimitriou1998, laporte1987, toth2014}. Esta clasificación se debe al crecimiento exponencial del tiempo requerido para resolverlos a medida que aumenta el número de nodos o clientes en la instancia.

Dada su complejidad computacional, estos problemas han sido abordados mediante diversas estrategias de solución que tienen como objetivo minimizar el costo total del recorrido, respetando las restricciones impuestas. Entre ellos se incluyen los métodos exactos, así como las técnicas heurísticas y metaheurísticas.

A continuación, se describen estos enfoques, junto con ejemplos representativos aplicados en los problemas mencionados.

\subsubsection{Métodos Exactos}

Son aquellos que parten de una formulación matemática del problema, generalmente como modelos de programación lineal entera o similares, y alcanzan soluciones factibles mediante algoritmos que acotan el conjunto de soluciones posibles \citep{luer2009}. Estos métodos garantizan la obtención de una solución óptima; sin embargo, su principal limitación radica en el alto costo computacional que implican, por lo que su eficiencia se restringe a instancias de tamaño reducido, de hasta aproximadamente 50 clientes en problemas de enrutamiento\citep{montes2017}.

Con base en la clasificación presentada por \citep{montes2017}, los métodos exactos pueden agruparse en las siguientes categorías:

\begin{enumerate}
	\item \textbf{Técnicas de relajación:} consisten en simplificar el modelo relajando ciertas restricciones complejas, lo que permite obtener cotas inferiores o superiores que guían la búsqueda de soluciones.
	\item \textbf{Búsqueda directa en árbol:} algoritmos como \emph{Branch and Bound} y \emph{Branch and Cut} exploran el espacio de soluciones mediante estructuras jerárquicas, descartando ramas no prometedoras.
	\item \textbf{Programación dinámica:} resuelve el problema descomponiéndolo en subproblemas más pequeños que se abordan de forma recursiva y eficiente.
	\item \textbf{Programación lineal entera:} utiliza modelos enteros mixtos como formulación clásica para problemas como el VRP-TW, y sirve frecuentemente de base para otros enfoques híbridos.
\end{enumerate}

Dado que el presente trabajo se enfoca en técnicas heurísticas y metaheurísticas, no se abordará en detalle la implementación de estos métodos exactos. Para una revisión más amplia, se remite al lector a \citep{montes2017}.

\subsubsection{Heurísticas}
\label{subsec:heuristica}

Heurística es un concepto cuyo origen se remonta a la Grecia clásica, derivado de la palabra griega heuriskein, que significa encontrar o descubrir. Según la historia, se asocia con eureka, la famosa exclamación atribuida a Arquímedes \citep{antonioSuarez2014}.

Para ejemplificar este concepto, se expone la siguiente definición:

\begin{quote}
	Según Zanakis et al.\ (citado en \citep{duarte2007metaheuristicas}), las heurísticas son \textit{``procedimientos simples, a menudo basados en el sentido común, que se supone que obtendrán una buena solución (no necesariamente óptima) a problemas difíciles de un modo sencillo y rápido''}.
\end{quote}

El desarrollo de las técnicas heurísticas clásicas aplicadas al VRP-TW se llevó a cabo principalmente entre las décadas de 1960 y 1990. Estas pueden clasificarse en tres categorías generales: métodos constructivos, métodos de dos fases y heurísticas de mejora \citep{montes2017}, las cuales se describen a continuación.

\textbf{Métodos constructivos:}
Las heurísticas constructivas elaboran progresivamente una solución factible, considerando los costos asociados en cada paso del proceso. Sin embargo, este tipo de métodos no incorpora una fase de mejora posterior sobre la solución obtenida \citep{toth2014}.

\textbf{Métodos de dos fases:}
Las heurísticas de dos fases dividen el problema en dos componentes principales: la agrupación de vértices en rutas factibles y la construcción de dichas rutas, pudiendo existir retroalimentación entre ambas etapas. Estas técnicas se clasifican en dos enfoques: agrupación primero, ruta después y ruta primero, agrupación después. En el primer enfoque, los vértices se organizan inicialmente en grupos factibles y luego se construye una ruta vehicular para cada uno. En el segundo, se genera primero un recorrido global que abarca todos los vértices y posteriormente se segmenta en rutas factibles \citep{toth2014}.

En el presente trabajo se emplearon heurísticas basadas en los métodos de mejora, por lo que no se profundizará en los demás enfoques. Para una descripción más detallada, se recomienda consultar \citep{montes2017, toth2014, olivera2004heur}.

\textbf{Métodos de mejora:}
Los métodos de mejora tienen como propósito optimizar una solución factible existente mediante una serie de intercambios o modificaciones de aristas y vértices, tanto dentro como entre rutas vehiculares, con el fin de disminuir el costo total del recorrido \citep{toth2014}.

Entre los operadores clásicos utilizados en los métodos de mejora para problemas de enrutamiento destacan los siguientes:

\begin{enumerate}
	\item \textbf{Operador de intercambio $\lambda$:} Consiste en eliminar $\lambda$ aristas de la solución y reconectar los $\lambda$ segmentos restantes. Una solución es óptima si no puede ser mejorada utilizando $\lambda$ intercambios \citep{olivera2004heur}.

	\item \textbf{Algoritmo de Lin-Kernighan:} Utiliza la idea de intercambiar un subconjunto de arcos por otro, donde dichos subconjuntos (y su cardinalidad) se modifican durante la ejecución del algoritmo. Se determinan dos conjuntos de aristas $x_1, ..., x_k$ e $y_1, ..., y_k$, tales que al realizar un intercambio entre estos disminuya el costo de la solución. Las aristas $x$ deben ser parte de la ruta, ambos conjuntos deben ser disjuntos y, además, eliminar las aristas $x$ y agregar las aristas $y$ formando una ruta cerrada \citep{montes2017}.

	\item \textbf{Operador Or-opt:} Consiste en eliminar una secuencia de $k$ clientes consecutivos de la ruta y colocarlos en otra posición de la ruta, de modo que permanezcan consecutivos y en el mismo orden \citep{montes2017, toth2014, olivera2004heur}.

	\item \textbf{GENI y GENIUS:} Surgen dentro de un método de solución para el TSP y tienen como principal característica que la inserción de un cliente en una ruta no necesariamente ocurre entre dos clientes adyacentes \citep{montes2017}.

	\item \textbf{Algoritmos de transferencias cíclicas:} Son movimientos multi-ruta que intentan eliminar clientes de una ruta y reubicarlos en otra de manera cíclica. También existe un movimiento que consiste en mover clientes de una ruta a otra en la misma posición \citep{montes2017}.

	\item \textbf{Operadores de Van Breedam:} El primero, denominado Cadena de Traslado (\textit{String Relocation}), se define como una secuencia de $m$ nodos que es transferida de una ruta a otra manteniendo el orden en la ruta original. El segundo, denominado Cadena de Intercambio (\textit{String Exchange}), intercambia una secuencia de $m$ clientes con una secuencia de $n$ clientes entre dos rutas  \citep{montes2017, toth2014, olivera2004heur}.
\end{enumerate}

En relación con lo expuesto en la subsubsection~\ref{subsec: clase_np}, los problemas de decisión pertenecientes a la clase NP presentan una complejidad tal que no es posible garantizar la obtención de una solución óptima en tiempo polinómico razonable.

En este contexto, los métodos heurísticos constituyen una alternativa eficaz para abordar el problema de optimización combinatoria VRP-TW, donde los métodos exactos resultan inviables a gran escala.

Por lo tanto, las heurísticas permiten obtener soluciones satisfactorias en tiempos razonables, priorizando el equilibrio entre la calidad de la solución y la eficiencia computacional. Aunque no garantizan la optimalidad, su aplicación resulta esencial cuando las soluciones exactas son \ prohibitivas.

\subsubsection{Metaheurísticas}

El término metaheurística fue introducido por Fred Glover en 1986 \citep{antonioSuarez2014}. Etimológicamente, deriva de la composición de dos palabras de origen griego: “meta” y “heurística”. El segundo término ha sido descrito en la subsección anterior~\ref{subsec:heuristica}, mientras que el prefijo “meta” puede traducirse como “más allá de” o “en un nivel superior” \citep{duarte2007metaheuristicas}.

Con este término, Glover pretendía definir un \textit{procedimiento maestro de alto nivel que guía y modifica otras heurísticas para explorar soluciones más allá de la simple optimalidad local} \citep{duarte2007metaheuristicas}.

Para ilustrar este concepto, cabe mencionar la definición propuesta por J. P. Kelly et al., citado por \citep{duarte2007metaheuristicas}:

\begin{quote}
	\textit{Las metaheurísticas son métodos aproximados especialmente diseñados para abordar problemas complejos de optimización combinatoria, donde los heurísticos tradicionales resultan ineficaces. Estas técnicas ofrecen un marco flexible para desarrollar algoritmos híbridos que integran conceptos provenientes de la inteligencia artificial, la evolución biológica y procesos estadísticos.}
\end{quote}

Para el problema clásico VRP-TW, se han implementado diversas metaheurísticas debido a su capacidad para ofrecer soluciones de buena calidad en tiempos razonables, especialmente cuando las técnicas exactas se vuelven ineficaces por la complejidad combinatoria del espacio de búsqueda.

Según \citep{antonioSuarez2014}, las metaheurísticas se clasifican de acuerdo con la fuente de inspiración que las fundamenta. A continuación, se describen brevemente tres categorías relevantes.

\subsubsection*{Algoritmos Evolutivos}

Los algoritmos evolutivos (EA, \emph{Evolutionary Algorithms}) constituyen una familia de técnicas inspiradas en los principios de la evolución biológica propuestos por Charles Darwin, principalmente en la selección natural y la supervivencia del más apto. Su objetivo es buscar soluciones óptimas o cercanas al óptimo mediante un proceso iterativo que simula la evolución de una población de individuos \cite{eiben2003introduction}.

El procedimiento general de un algoritmo evolutivo puede describirse de la siguiente manera \cite{back1997handbook}:

\begin{enumerate}
	\item \textbf{Inicialización:} Se genera una población inicial de individuos de manera aleatoria o siguiendo algún criterio heurístico.
	\item \textbf{Evaluación:} Cada individuo es evaluado mediante la función de aptitud.
	\item \textbf{Selección:} Se eligen los individuos más aptos para reproducirse.
	\item \textbf{Recombinación y mutación:} Se aplican operadores que combinan y modifican las soluciones seleccionadas para crear nuevas generaciones.
	\item \textbf{Reemplazo:} Se forma una nueva población con los individuos más aptos de la generación actual y las nuevas soluciones.
	\item \textbf{Criterio de parada:} El proceso se repite hasta alcanzar un número máximo de iteraciones o una solución satisfactoria.
\end{enumerate}

Cada individuo representa una posible solución al problema y se evalúa mediante una función de aptitud o \textit{fitness}, que mide qué tan buena es la solución respecto al objetivo. A partir de esta población inicial, se aplican operadores evolutivos que imitan la reproducción y la mutación biológica, generando nuevas soluciones.

\subsubsection*{Algoritmos Genéticos}

Los algoritmos genéticos (GA, \emph{Genetic Algorithms}) son una de las técnicas más representativas dentro de los algoritmos evolutivos. Propuestos inicialmente por John Holland en la década de 1970 \cite{holland1975adaptation}, estos algoritmos utilizan una representación basada en \textit{cromosomas}, los cuales codifican posibles soluciones al problema. Los operadores principales que emplean son \cite{goldberg1989genetic}:

\begin{itemize}
	\item \textbf{Cruzamiento (crossover):} combina la información de dos individuos para generar descendencia con características de ambos.
	\item \textbf{Mutación:} introduce pequeñas variaciones aleatorias para mantener la diversidad genética y evitar la convergencia prematura.
	\item \textbf{Selección:} elige los individuos más aptos para reproducirse, simulando la presión evolutiva.
\end{itemize}

Estos algoritmos destacan por su capacidad para explorar de manera eficiente grandes espacios de búsqueda y adaptarse a distintas configuraciones del problema. Gracias a la combinación de operadores genéticos y mecanismos de selección, los GA permiten generar soluciones robustas y competitivas incluso en escenarios de alta complejidad combinatoria.

Aunque los algoritmos evolutivos (EA) y los algoritmos genéticos (GA) han sido descritos de manera general, a continuación se presenta una variante de especial relevancia para esta investigación. Dicha técnica será fundamental en el desarrollo del presente trabajo, ya que se implementará como parte del enfoque de optimización propuesto. En la siguiente sección se describe el funcionamiento del algoritmo de Evolución Diferencial (DE).

\subsubsection*{Evolución Diferencial (DE)}

Dentro de la familia de los algoritmos evolutivos, la Evolución Diferencial (\emph{Differential Evolution}, DE) se ha consolidado como una de las técnicas más eficaces para la optimización de problemas continuos, debido a su simplicidad conceptual, bajo número de parámetros de control y alta capacidad de exploración del espacio de búsqueda \cite{storn1997differential,price2005differential}.

El DE comparte los fundamentos biológicos de otras metaheurísticas evolutivas, como la selección natural y la supervivencia del más apto, pero se diferencia por su mecanismo basado en combinaciones vectoriales de diferencias entre individuos de la población, lo que le permite mantener un equilibrio adecuado entre exploración y explotación.

Este algoritmo trabaja con una población de soluciones candidatas representadas como vectores de valores reales, que evolucionan a lo largo de varias generaciones mediante tres operadores principales: mutación, recombinación y selección. De manera general, su funcionamiento puede describirse de la siguiente forma:

\begin{itemize}
	\item \textbf{Mutación:} genera un vector mutante $v_i$ combinando individuos de la población. Una de las estrategias más utilizadas es \textbf{DE/rand/1}:
	      \begin{equation}
		      v_i = x_{r_1} + F \cdot (x_{r_2} - x_{r_3})
	      \end{equation}
	      \addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Vector mutante en Evolución Diferencial (DE/rand/1)}
	      donde $r_1, r_2, r_3$ son índices aleatorios distintos entre sí y diferentes de $i$, y $F$ es el factor de mutación ($F \in [0, 2]$, típicamente entre 0.5 y 1). Este operador introduce diversidad y permite explorar nuevas regiones del espacio de búsqueda.

	\item \textbf{Recombinación:} combina el vector mutante con el vector original $x_i$ para formar un vector de prueba $u_i$, siguiendo el esquema de cruce binomial:
	      \begin{equation}
		      u_{i,j} =
		      \begin{cases}
			      v_{i,j} & \text{si } \text{rand}() \leq CR \\
			      x_{i,j} & \text{en otro caso}
		      \end{cases}
	      \end{equation}
	      \addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Cruce binomial en Evolución Diferencial}
	      donde $CR \in [0, 1]$ es la tasa de cruce o probabilidad de recombinación. Este operador combina información de distintas soluciones, favoreciendo la explotación de configuraciones prometedoras.

	\item \textbf{Selección:} compara el vector de prueba $u_i$ con el individuo original $x_i$ mediante la función objetivo, conservando únicamente el de mejor aptitud para la siguiente generación:
	      \begin{equation}
		      x_i^{(t+1)} =
		      \begin{cases}
			      u_i       & \text{si } f(u_i) < f(x_i^{(t)}) \\
			      x_i^{(t)} & \text{en otro caso}
		      \end{cases}
	      \end{equation}
	      \addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Operador de selección en Evolución Diferencial}
	      Este mecanismo garantiza la mejora progresiva de la población, evitando el deterioro de soluciones de alta calidad.
\end{itemize}

\subsubsection*{Metaheurísticas inspiradas en la biología}

Una clase particular de metaheurísticas que ha ganado gran popularidad en los últimos años se basa en reglas inspiradas en conceptos biológicos, tales como la evolución natural, el comportamiento de las hormigas o los patrones de vuelo de las aves. A este conjunto de técnicas se le conoce como metaheurísticas bio-inspiradas \cite{coello2022metaheuristicas}. Estas técnicas buscan reproducir comportamientos colectivos o procesos naturales que conducen a la emergencia de soluciones eficientes sin supervisión centralizada.

Un ejemplo representativo de este tipo de técnicas es la Optimización por Colonias de Hormigas, la cual es una metaheurística bio-inspirada y relativamente reciente \citep{antonioSuarez2014}.

\subsubsection*{Optimización por Colonias de Hormigas}

La Optimización por Colonias de Hormigas conocido por sus siglas en inglés como ACO (\textit{Ant Colony Optimization}) es una metaheurística bio-inspirada que toma como referencia el comportamiento colectivo de las hormigas al buscar caminos eficientes entre su colonia y una fuente de alimento \citep{dorigo1997ant}.

En la naturaleza, las hormigas depositan una sustancia química llamada feromona sobre el suelo al desplazarse. A mayor cantidad de feromona en un camino, mayor es la probabilidad de que otras hormigas lo sigan. Con el tiempo, los caminos más cortos tienden a concentrar más feromonas, ya que son recorridos con mayor frecuencia. Este mecanismo colectivo da lugar a la autoorganización y a la aparición de soluciones eficientes sin supervisión centralizada \citep{cobos2010,dorigo1997ant}.

De forma análoga, en ACO cada hormiga representa una solución candidata al problema de optimización. Las decisiones de construcción de soluciones están guiadas por dos factores: la cantidad de feromona acumulada en cada componente de la solución y una medida heurística que representa la deseabilidad local. La selección del siguiente componente se realiza mediante una regla de transición estocástica que pondera ambos factores \citep{cobos2010}.

El algoritmo opera iterativamente: un conjunto de hormigas construye soluciones, se evalúan los costos de las mismas, se actualiza la cantidad de feromona en función de la calidad de las rutas encontradas y se repite el proceso durante un número determinado de iteraciones o hasta alcanzar una condición de parada. Con el tiempo, el sistema converge hacia soluciones de alta calidad \citep{dorigo1997ant}.

\subsubsection*{Modelo de selección probabilística en la Optimización por Colonias de Hormigas}

En el algoritmo de Optimización por Colonias de Hormigas, la probabilidad de que una hormiga en el nodo \( i \) seleccione el nodo \( j \) como siguiente destino se calcula utilizando la siguiente expresión \citep{dorigo1997ant}:

\begin{equation}
	p_{ij}^k(t) =
	\begin{cases}
		\dfrac{[\tau_{ij}(t)]^{\alpha} \cdot [\eta_{ij}]^{\beta}}
		{\displaystyle\sum_{l \in \mathcal{N}_i^k} [\tau_{il}(t)]^{\alpha} \cdot [\eta_{il}]^{\beta}}, & \text{si } j \in \mathcal{N}_i^k, \\[1.2em]
		0,                                                                                             & \text{en otro caso.}
	\end{cases}
	\label{eq:prob_aco_dorigo}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Regla de transición en ACO}

donde:
\begin{itemize}
	\item \( p_{ij}^k(t) \): probabilidad de que la hormiga \( k \) se desplace del nodo \( i \) al nodo \( j \) en el tiempo \( t \),
	\item \( \tau_{ij}(t) \): cantidad de feromona en el borde \( (i, j) \) en el tiempo \( t \),
	\item \( \eta_{ij} = \frac{1}{d_{ij}} \): visibilidad heurística, usualmente el inverso de la distancia,
	\item \( \alpha \): parámetro que regula la influencia de la feromona,
	\item \( \beta \): parámetro que regula la influencia de la heurística,
	\item \( \mathcal{N}_i^k \): conjunto de nodos aún no visitados por la hormiga \( k \) al estar en \( i \).
\end{itemize}

Esta regla de transición balancea el conocimiento aprendido (feromonas) y la heurística (visibilidad), dirigiendo la exploración de las hormigas a lo largo del espacio de soluciones. Fue propuesta originalmente por Dorigo, Maniezzo y Colorni en sus estudios sobre el TSP \citep{dorigo1997ant}.

\subsubsection*{Metaheurísticas inspiradas en la física}

Este tipo de metaheurísticas toma como referencia principios y fenómenos físicos para guiar el proceso de búsqueda de soluciones óptimas. Un ejemplo representativo es el Recocido Simulado \citep{antonioSuarez2014}.

\subsubsection*{Recocido Simulado}

El Recocido Simulado (*Simulated Annealing*, SA) es una metaheurística inspirada en el proceso físico de recocido de los metales, donde se calienta un sólido a altas temperaturas y luego se enfría de manera controlada, permitiendo que sus partículas se reorganicen y alcancen una estructura de mínima energía \citep{cobos2010}.

De forma análoga, en el contexto de la optimización combinatoria, cada solución posible del problema se considera un “estado” del sistema, y su calidad se mide como si fuera una “energía”. El objetivo es encontrar el estado (solución) con la menor energía (mejor valor de la función objetivo) \citep{cobos2010}.

El algoritmo comienza con una solución inicial y, en cada iteración, genera una nueva solución vecina. Si la nueva solución es mejor, se acepta; si es peor, puede ser aceptada con una cierta probabilidad que depende de un parámetro llamado “temperatura”. A medida que el algoritmo avanza, la temperatura disminuye, reduciendo así la probabilidad de aceptar soluciones peores. Este mecanismo permite escapar de óptimos locales y explorar mejor el espacio de soluciones \citep{cobos2010}.

Este enfoque resulta particularmente útil en problemas de optimización combinatoria, donde el objetivo es minimizar una función de costo (por ejemplo, distancia total recorrida, tiempo o penalizaciones por restricciones de ventanas de tiempo). Al incorporar una aceptación probabilística de soluciones no óptimas, el algoritmo equilibra la exploración y la explotación, favoreciendo una búsqueda más efectiva del óptimo global.

\subsubsection*{Modelo de distribución de Maxwell-Boltzmann aplicado al Recocido Simulado}

La distribución de Maxwell-Boltzmann describe la probabilidad de que un sistema físico adopte un estado con una energía \( E_i \) a una temperatura \( T \). Esta probabilidad se expresa como:

\begin{equation}
	p_i = \frac{e^{-E_i / kT}}{Z}
	\label{eq:maxwell_boltzmann}
\end{equation}
\addcontentsline{eq}{myequations}{\protect\numberline{\theequation} Distribución de Boltzmann}

donde se tiene que:
\begin{itemize}
	\item \( p_i \): probabilidad de que el sistema se encuentre en el estado \( i \),
	\item \( E_i \): energía del estado \( i \),
	\item \( k \): constante de Boltzmann,
	\item \( T \): temperatura absoluta del sistema,
	\item \( Z = \sum_j e^{-E_j / kT} \): función de partición que normaliza las probabilidades.
\end{itemize}

Este modelo permite explicar cómo se distribuyen los estados energéticos en sistemas en equilibrio térmico, y es ampliamente utilizado como base probabilística en algoritmos como el SA para justificar la aceptación de soluciones peores durante las fases iniciales del proceso de enfriamiento \citep{kirkpatrick1983optimization}.

Cada una de las metaheurísticas mencionadas —Evolución Diferencial (DE), Optimización por Colonias de Hormigas (ACO) y Recocido Simulado (SA)— puede aplicarse eficazmente a problemas de optimización complejos. Estas técnicas han demostrado ser herramientas valiosas en la resolución del VRP-TW, gracias a su capacidad para explorar amplios espacios de búsqueda y aproximarse a soluciones óptimas en tiempos computacionales razonables.

Si bien existen numerosas estrategias metaheurísticas documentadas en la literatura, en este trabajo se han seleccionado estas tres por su relevancia teórica, versatilidad y desempeño comprobado en problemas de optimización combinatoria. En el siguiente capítulo se describirá detalladamente la forma en que cada una de estas técnicas fue adaptada e implementada dentro del contexto de la presente investigación.

\subsubsection{Algoritmos Híbridos}

Los algoritmos híbridos combinan características de diferentes metaheurísticas con el objetivo de aprovechar las ventajas de cada una y superar las limitaciones individuales. Este tipo de enfoques surge de la necesidad de mejorar la eficiencia, precisión y robustez en la resolución de problemas de optimización complejos \cite{eiben2003introduction, blum2003metaheuristics}.

En un algoritmo híbrido, se pueden combinar técnicas evolutivas con búsquedas locales, métodos exactos o incluso otras metaheurísticas, generando un enfoque que equilibra exploración y explotación de manera más efectiva que las técnicas puras \cite{goldberg1989genetic}. La idea central es utilizar las fortalezas de cada técnica para complementar las debilidades de las demás, obteniendo así soluciones de mayor calidad en menos tiempo.

Los algoritmos híbridos son especialmente valiosos para el problema VRP-TW, donde la complejidad del espacio de soluciones puede ser muy elevada \cite{vargas2016}. Gracias a la combinación de estrategias, estos algoritmos pueden:
\begin{itemize}
	\item Mejorar la convergencia hacia soluciones cercanas al óptimo.
	\item Reducir la probabilidad de estancamiento en óptimos locales.
	\item Manejar restricciones adicionales de manera más eficiente.
\end{itemize}

\textbf{Ejemplos de algoritmos híbridos:}
\begin{itemize}
	\item \textbf{GA + Búsqueda Local:} combina algoritmos genéticos con operadores de mejora local para refinar las soluciones generadas por la población; es útil en el TSP, el VRP y su variante con ventanas de tiempo, el VRP-TW.
	\item \textbf{DE + Recocido Simulado (SA):} integra Evolución Diferencial con Recocido Simulado, equilibrando exploración global y ajuste fino de soluciones.
	\item \textbf{ACO + Algoritmo Genético:} emplea la información de feromonas generada por Colonias de Hormigas como semilla para un algoritmo genético, acelerando la convergencia en problemas VRP-TW.
\end{itemize}

Por estas razones, los algoritmos híbridos se han consolidado como herramientas poderosas para resolver problemas complejos en logística, planificación de rutas, diseño de redes y otras áreas donde las metaheurísticas puras podrían no ser suficientes \cite{blum2003metaheuristics, eiben2003introduction}.

En este trabajo se adopta un enfoque híbrido que integra el Algoritmo Evolutivo Diferencial (DE), la Optimización por Colonias de Hormigas (ACO) y el Recocido Simulado (SA) para abordar el VRP-TW, como se mencionó anteriormente. Esta combinación busca aprovechar las fortalezas complementarias de cada técnica. De esta manera, el enfoque híbrido propuesto no solo mejora la calidad de las soluciones obtenidas, sino que también contribuye a reducir el tiempo de cómputo necesario para alcanzar resultados competitivos.

En el siguiente capítulo se explicará con detalle cada etapa de nuestro algoritmo híbrido.

\section{Referencias Relevantes}
El Problema del Agente Viajero (TSP) constituye uno de los problemas fundamentales en optimización combinatoria y ha sido objeto de estudio desde principios del siglo XX. \cite{dantzig1954solution} presentaron la primera formulación matemática rigurosa del TSP y desarrollaron el método de planos de corte, estableciendo las bases teóricas para su resolución. Posteriormente, \cite{held1962dynamic} propusieron un algoritmo de programación dinámica que reduce la complejidad computacional, aunque el problema permanece como NP-difícil. La importancia del TSP radica en que constituye el fundamento teórico de problemas más complejos de ruteo, siendo ampliamente estudiado tanto desde la perspectiva teórica como aplicada.

El Problema de Ruteo de Vehículos (VRP), introducido por \cite{dantzig1959truck}, representa una generalización natural del TSP al considerar múltiples vehículos con capacidad limitada. Este trabajo seminal estableció el VRP como un problema central en logística y distribución. \cite{clarke1964scheduling} desarrollaron el algoritmo de ahorros, una de las heurísticas constructivas más influyentes que continúa siendo referencia en el campo. \cite{laporte1992vehicle} realizó una revisión comprehensiva de los métodos exactos para el VRP, consolidando el conocimiento acumulado durante tres décadas de investigación. \cite{toth2002vehicle} compilaron el estado del arte en su obra ``The Vehicle Routing Problem'', que se ha convertido en referencia obligada para investigadores en el área.

El Problema de Ruteo de Vehículos con Ventanas de Tiempo (VRP-TW), que constituye el enfoque principal de este trabajo, fue formalmente definido por \cite{solomon1987algorithms}, quien además generó el conjunto de instancias de prueba que se ha convertido en el estándar de la industria para evaluar algoritmos. Solomon clasificó las instancias en seis categorías (C1, C2, R1, R2, RC1, RC2) según la distribución geográfica de los clientes y la amplitud de las ventanas de tiempo, estableciendo un marco de referencia que permanece vigente. \cite{desrosiers1995time} desarrollaron métodos exactos basados en generación de columnas y programación dinámica, demostrando la viabilidad teórica de resolver instancias de tamaño moderado de manera óptima.

En cuanto a enfoques metaheurísticos para el VRP-TW, \cite{braysy2005vehicle1, braysy2005vehicle2} publicaron una revisión exhaustiva en dos partes que analiza más de 200 trabajos, clasificando las metaheurísticas en búsqueda local, métodos basados en población y enfoques híbridos. \cite{taillard1997tabu} introdujeron la Búsqueda Tabú adaptativa para el VRP-TW, estableciendo nuevos estándares de calidad en las soluciones. \cite{gambardella1999macs} aplicaron el sistema de Colonia de Hormigas con múltiples colonias (MACS-VRP-TW), demostrando la efectividad de algoritmos bio-inspirados en este dominio.

Los algoritmos genéticos han mostrado particular eficacia para el VRP-TW. \cite{potvin1996vehicle} desarrollaron un algoritmo genético con operadores especializados que considera simultáneamente la minimización de vehículos y distancia total. \cite{homberger1999two} propusieron un algoritmo evolutivo de dos fases que logró resultados competitivos en instancias de gran escala. Más recientemente, \cite{vidal2012hybrid} presentaron un algoritmo genético híbrido (HGSADC) que incorpora búsqueda local intensiva y mecanismos de control de diversidad, estableciendo nuevos mejores resultados conocidos en múltiples instancias de Solomon.

La hibridación de metaheurísticas representa una tendencia consolidada en la literatura reciente. \cite{nagata2009powerful} combinaron búsqueda local guiada y penalización adaptativa, mientras que \cite{pisinger2007general} desarrollaron el enfoque de Large Neighborhood Search (LNS) adaptativo, que ha sido extensamente aplicado en variantes del VRP. \cite{baldacci2012recent} presentaron una revisión de métodos exactos de última generación, destacando enfoques branch-and-cut-and-price que han permitido resolver instancias previamente intratables.

\chapter{Materiales y Métodos}
\label{cap:materialesymetodos}

\section{Materiales}

Para el desarrollo y evaluación del algoritmo híbrido propuesto para resolver el VRP-TW, se emplearon los siguientes materiales y recursos:

\subsection{Datos e instancias del problema}

Para la evaluación del algoritmo implementado se utilizaron conjuntos de datos de referencia para el problema de VRP-TW:

\begin{itemize}
	\item \textbf{Instancias Solomon para VRP-TW:} Se emplearon las instancias clásicas de Solomon, incluyendo los conjuntos:
	      \begin{itemize}
		      \item C101-C109, C201-C208
		      \item R101-R112, R201-R211
		      \item RC101-RC108, RC201-RC208
	      \end{itemize}
	      Cada instancia contiene un número específico de clientes (25, 50 o 100), permitiendo evaluar el desempeño de los algoritmos en problemas de diferente tamaño y complejidad.

	\item \textbf{Información de vehículos:} Cada vehículo de la flota cuenta con una capacidad máxima, utilizada para asegurar que la asignación de clientes no exceda los límites permitidos. Por ejemplo:
	      \begin{center}
		      \begin{tabular}{cc}
			      \hline
			      \textbf{Número de vehículos} & \textbf{Capacidad} \\
			      \hline
			      25                           & 200                \\
			      \hline
		      \end{tabular}
	      \end{center}

	\item \textbf{Información de clientes:} Cada cliente está definido por coordenadas geográficas, demanda, ventana de tiempo y tiempo de servicio, siguiendo el formato:
	      \begin{center}
		      \small % Reduce el tamaño de la fuente
		      \begin{tabular}{ccccccc}
			      \hline
			      \textbf{CUST} & \textbf{XCOORD} & \textbf{YCOORD} & \textbf{DEMAND} & \textbf{READY} & \textbf{DUE}  & \textbf{SERVICE} \\
			      \textbf{NO.}  &                 &                 &                 & \textbf{TIME}  & \textbf{DATE} & \textbf{TIME}    \\
			      \hline
			      1             & 45              & 30              & 10              & 0              & 200           & 10               \\
			      2             & 20              & 50              & 15              & 0              & 180           & 15               \\
			      \vdots        & \vdots          & \vdots          & \vdots          & \vdots         & \vdots        & \vdots           \\
			      \hline
		      \end{tabular}
	      \end{center}
	      Esta información es utilizada por los algoritmos para determinar la asignación de clientes a vehículos y planificar las rutas cumpliendo con las restricciones de capacidad y ventanas de tiempo.
\end{itemize}

\noindent En conjunto, estas instancias permiten evaluar el desempeño, eficiencia y calidad de las soluciones generadas por los algoritmos para distintos tamaños y configuraciones del problema VRPTW.


\subsection{Software}

Para el desarrollo de esta investigación se utilizaron los siguientes lenguajes, entornos y bibliotecas:

\begin{itemize}
	\item \textbf{Lenguajes de programación:}
	      \begin{itemize}
		      \item \textbf{C:} Fue el lenguaje principal utilizado para la implementación de los algoritmos, debido a su naturaleza de bajo y alto nivel, lo que permitió un control preciso de la memoria y estructuras de datos, así como una ejecución rápida, fundamental para la simulación de problemas de alta complejidad como el VRP-TW.
		      \item \textbf{Python:} Se empleó principalmente para procesar los archivos \texttt{JSON} generados por la implementación en C, y para la creación de gráficos estáticos y animaciones dinámicas de las rutas de los vehículos, aprovechando bibliotecas especializadas en visualización.
	      \end{itemize}

	\item \textbf{Entorno de desarrollo:} Visual Studio Code fue utilizado como IDE principal por su versatilidad, compatibilidad con múltiples lenguajes y facilidad para depurar y organizar proyectos complejos.

	\item \textbf{Bibliotecas:}
	      \begin{itemize}
		      \item \textbf{C:}
		            \begin{verbatim}
					#include <stdio.h>
					#include <stdlib.h>
					#include <math.h>
					#include <time.h>
					#include <dirent.h>
					#include <sys/stat.h>
					#include <unistd.h>
					#include <string.h>
					#include <cjson/cJSON.h>
        \end{verbatim}
		            Estas bibliotecas permitieron manejar entrada/salida, estructuras de datos, funciones matemáticas, manipulación de directorios, tiempos de ejecución y procesamiento de archivos JSON.

		      \item \textbf{Python:}
		            \begin{verbatim}
					import json
					import os
					import sys
					import matplotlib.pyplot as plt
					import matplotlib.animation as animation
					import numpy as np
					import time
					from matplotlib.patches import Circle
        \end{verbatim}
		            Estas bibliotecas se usaron para el análisis de datos, generación de gráficos estáticos y animados, manejo de arreglos y matrices, así como la visualización de rutas y simulaciones dinámicas.
	      \end{itemize}
\end{itemize}


\subsection{Hardware}

El desarrollo completo del código y la ejecución de los experimentos se realizaron utilizando una computadora principal con las siguientes características, que también se utilizó para la recolección de resultados:

\begin{itemize}
	\item \textbf{Procesador:} Intel Core i7 de 10.ª generación.
	\item \textbf{Memoria RAM:} 20 GB.
	\item \textbf{Sistema operativo:} Linux (Debian 12).
\end{itemize}

Adicionalmente, se emplearon otras computadoras para la recolección de datos:

\paragraph{Computadora 1:}
\begin{itemize}
	\item \textbf{Procesador:} Intel Core i5 de 11.ª generación.
	\item \textbf{Memoria RAM:} 12 GB.
	\item \textbf{Sistema operativo:} Windows 11.
\end{itemize}

\paragraph{Computadora 2:}
\begin{itemize}
	\item \textbf{Procesador:} Intel Core i3 de 6.ª generación.
	\item \textbf{Memoria RAM:} 8 GB.
	\item \textbf{Sistema operativo:} Linux (Ubuntu).
\end{itemize}

Estas configuraciones permitieron realizar pruebas de ejecución de los algoritmos y generar los datos necesarios para el análisis de resultados, considerando diferentes capacidades de hardware para evaluar la eficiencia y escalabilidad de los métodos implementados.


\subsection{Herramientas de apoyo}

Para complementar el desarrollo de esta investigación y facilitar la presentación de resultados, se emplearon las siguientes herramientas de apoyo:

\begin{itemize}
	\item \textbf{Redacción y documentación:} Se utilizó \LaTeX{} como principal herramienta para la escritura de la tesis y la documentación del proyecto. Esto permitió generar un documento con formato profesional, manejo automático de referencias bibliográficas, índices, tablas, figuras y ecuaciones, asegurando uniformidad y claridad en la presentación de los resultados.

	\item \textbf{Control de versiones y organización:} Se utilizó Git como sistema de control de versiones para mantener un registro completo de los cambios realizados en el código fuente, asegurando trazabilidad y facilitando la colaboración eficiente durante la recolección.
\end{itemize}


\section{Métodos}

\subsection{Descripción general del algortimo híbrido}

Para resolver el problema de VRP-TW, se propone un algoritmo híbrido que combina tres técnicas metaheurísticas: Algoritmo Evolutivo Diferencial (DE), Optimización por Colonia de Hormigas (ACO) y Recocido Simulado (SA).
Este enfoque aprovecha la capacidad de exploración global del ACO, la explotación local del SA y la calibración automática de parámetros mediante DE, con el objetivo de generar soluciones de alta calidad de manera eficiente.

El flujo jerárquico del método híbrido es el siguiente:

\begin{enumerate}
	\item \textbf{Algoritmo Evolutivo Diferencial (DE):} se encarga de calibrar los parámetros de ACO y SA para optimizar la búsqueda de soluciones.
	\item \textbf{Optimización por Colonia de Hormigas (ACO):} genera rutas iniciales factibles, cumpliendo las restricciones de capacidad y ventanas de tiempo de los vehículos o clientes.
	\item \textbf{Recocido Simulado (SA):} refina las rutas iniciales aplicando heurísticas de mejora local sin violas las restricciones mecionadas con anterioridad y aceptando soluciones subóptimas bajo un criterio probabilístico, lo que permite escapar de óptimos locales.
\end{enumerate}

El objetivo principal del enfoque propuesto es generar soluciones de alta calidad para instancias de VRP-TW, cumpliendo con las restricciones de capacidad de los vehículos y las ventanas de tiempo de los clientes, y optimizando la eficiencia y robustez del método a través de la calibración automática de parámetros y el refinamiento de rutas.

\subsection{Calibración de parámetros mediante Evolución Diferencial}

Como primera etapa del enfoque híbrido, se emplea el Algoritmo Evolutivo Diferencial (DE) con el objetivo de calibrar los parámetros de las metaheurísticas ACO y SA de manera automatica. Esta calibración permite maximizar la calidad de las soluciones obtenidas por ACO y SA para el VRP-TW.

Como se hizo mencion en la seccion anterior, cada instancia fue segametada en 3 partes la cual se especifica en la siguiente tabla:

\begin{table}[h]
	\centering
	\begin{tabular}{|l|c|}
		\hline
		\textbf{Tamaño del problema} & \textbf{Número de clientes} \\
		\hline
		Pequeña                      & 25                          \\
		\hline
		Mediana                      & 50                          \\
		\hline
		Grande                       & 100                         \\
		\hline
	\end{tabular}
	\caption{Clasificación de instancias según número de clientes}
\end{table}



Sin importar la instancia o sus medidas, se realizó el proceso de calibración que optimiza simultáneamente los siguientes parámetros:

\begin{itemize}
	\item \textbf{Para ACO:}
	      \begin{itemize}
		      \item $\alpha$: influencia de la información de feromonas
		      \item $\beta$: influencia de la información heurística (distancia)
		      \item $\gamma$: peso de las restricciones de ventanas de tiempo
		      \item $\rho$: tasa de evaporación de feromonas
		      \item Número de hormigas
		      \item Porcentaje de hormigas
		      \item Número de iteraciones
	      \end{itemize}

	\item \textbf{Para SA:}
	      \begin{itemize}
		      \item Temperatura inicial ($T_0$)
		      \item Temperatura final ($T_f$)
		      \item Factor de enfriamiento ($\alpha_{cool}$)
		      \item Número de iteraciones
	      \end{itemize}
\end{itemize}

Para ambas metaheurísticas, es necesario definir rangos mínimos y máximos de los parámetros, y ajustar estos rangos según el tamaño específico de la instancia (pequeña, mediana o grande). Esto asegura que el algoritmo pueda adaptarse dinámicamente a la complejidad del problema.


\subsubsection{Configuración de rangos de parámetros según tamaño de instancia}

La calibración efectiva del algoritmo híbrido requiere establecer rangos de búsqueda apropiados para los parámetros de ACO y SA, adaptados a la complejidad de cada instancia. A continuación se presentan los rangos definidos para tres categorías de tamaño: pequeña (25 clientes), mediana (50 clientes) y grande (100 clientes). Estos rangos se ajustan progresivamente para equilibrar la exploración del espacio de soluciones con la eficiencia computacional.

\subsubsection*{Instancias Pequeñas (25 clientes)}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|l|c|c|}
		\hline
		\multicolumn{3}{|c|}{\textbf{Parámetros ACO}} & \multicolumn{3}{c|}{\textbf{Parámetros SA}}                                                                       \\
		\hline
		\textbf{Parámetro}                            & \textbf{Mín.}                               & \textbf{Máx.} & \textbf{Parámetro}  & \textbf{Mín.} & \textbf{Máx.} \\
		\hline
		$\alpha$                                      & 2.0                                         & 3.5           & Temperatura inicial & 1200.0        & 1800.0        \\
		\hline
		$\beta$                                       & 2.5                                         & 4.0           & Temperatura final   & 0.01          & 0.1           \\
		\hline
		$\gamma$                                      & 1.0                                         & 2.5           & Factor enfriamiento & 0.95          & 0.98          \\
		\hline
		$\rho$                                        & 0.3                                         & 0.5           & Iteraciones SA      & 80            & 120           \\
		\hline
		Número de hormigas                            & 3                                           & 6             &                     &               &               \\
		\cline{1-3}
		Iteraciones ACO                               & 60                                          & 80            &                     &               &               \\
		\hline
	\end{tabular}
	\caption{Rangos de parámetros para instancias pequeñas}
	\label{tab:param_pequenas}
\end{table}

Para instancias pequeñas se establecen rangos moderados que equilibran exploración y explotación sin incurrir en costos computacionales innecesarios. Los valores de $\alpha$ (2.0--3.5) y $\beta$ (2.5--4.0) balancean la influencia de feromonas e información heurística, mientras que $\rho$ (0.3--0.5) mantiene diversidad mediante evaporación moderada. El parámetro $\gamma$ (1.0--2.5) prioriza inicialmente el cumplimiento de ventanas de tiempo. Con 3--6 hormigas y 60--80 iteraciones ACO, seguidas de 80--120 iteraciones SA con temperatura inicial moderada (1200.0--1800.0), se logra refinamiento eficiente en espacios de búsqueda reducidos.

\subsubsection*{Instancias Medianas (50 clientes)}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|l|c|c|}
		\hline
		\multicolumn{3}{|c|}{\textbf{Parámetros ACO}} & \multicolumn{3}{c|}{\textbf{Parámetros SA}}                                                                       \\
		\hline
		\textbf{Parámetro}                            & \textbf{Mín.}                               & \textbf{Máx.} & \textbf{Parámetro}  & \textbf{Mín.} & \textbf{Máx.} \\
		\hline
		$\alpha$                                      & 2.5                                         & 4.0           & Temperatura inicial & 1600.0        & 2200.0        \\
		\hline
		$\beta$                                       & 3.5                                         & 5.0           & Temperatura final   & 0.005         & 0.05          \\
		\hline
		$\gamma$                                      & 1.5                                         & 3.0           & Factor enfriamiento & 0.97          & 0.99          \\
		\hline
		$\rho$                                        & 0.25                                        & 0.45          & Iteraciones SA      & 120           & 200           \\
		\hline
		Número de hormigas                            & 6                                           & 12            &                     &               &               \\
		\cline{1-3}
		Iteraciones ACO                               & 100                                         & 150           &                     &               &               \\
		\hline
	\end{tabular}
	\caption{Rangos de parámetros para instancias medianas}
	\label{tab:param_medianas}
\end{table}

En instancias medianas se incrementan los rangos para fortalecer la exploración en espacios de búsqueda más amplios. Los valores elevados de $\alpha$ (2.5--4.0) y $\beta$ (3.5--5.0) intensifican la influencia de feromonas e información heurística. La tasa de evaporación reducida $\rho$ (0.25--0.45) preserva mejor las buenas soluciones en la memoria colectiva. Con 6--12 hormigas y 100--150 iteraciones ACO, seguidas de refinamiento SA más exhaustivo (120--200 iteraciones, temperatura inicial 1600.0--2200.0), se equilibra calidad de solución y tiempo de cómputo en problemas de complejidad intermedia.

\subsubsection*{Instancias Grandes (100 clientes)}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|l|c|c|}
		\hline
		\multicolumn{3}{|c|}{\textbf{Parámetros ACO}} & \multicolumn{3}{c|}{\textbf{Parámetros SA}}                                                                       \\
		\hline
		\textbf{Parámetro}                            & \textbf{Mín.}                               & \textbf{Máx.} & \textbf{Parámetro}  & \textbf{Mín.} & \textbf{Máx.} \\
		\hline
		$\alpha$                                      & 3.0                                         & 5.0           & Temperatura inicial & 2500.0        & 4000.0        \\
		\hline
		$\beta$                                       & 4.0                                         & 6.0           & Temperatura final   & 0.001         & 0.01          \\
		\hline
		$\gamma$                                      & 2.0                                         & 4.0           & Factor enfriamiento & 0.97          & 0.995         \\
		\hline
		$\rho$                                        & 0.10                                        & 0.30          & Iteraciones SA      & 200           & 300           \\
		\hline
		Número de hormigas                            & 10                                          & 20            &                     &               &               \\
		\cline{1-3}
		Iteraciones ACO                               & 120                                         & 180           &                     &               &               \\
		\hline
	\end{tabular}
	\caption{Rangos de parámetros para instancias grandes}
	\label{tab:param_grandes}
\end{table}

Para instancias grandes se emplean rangos amplios que permiten exploración robusta en espacios de alta dimensionalidad. Los valores máximos de $\alpha$ (3.0--5.0) y $\beta$ (4.0--6.0) intensifican la explotación de soluciones prometedoras, mientras que $\rho$ reducida (0.10--0.30) preserva conocimiento acumulado por más tiempo. El parámetro $\gamma$ (2.0--4.0) alcanza sus valores máximos, reforzando el cumplimiento de ventanas de tiempo en problemas complejos. Con 10--20 hormigas, 120--180 iteraciones ACO y refinamiento SA intensivo (200--300 iteraciones, temperatura inicial elevada 2500.0--4000.0), se justifica el mayor costo computacional mediante la obtención de soluciones de alta calidad.

\vspace{0.3cm}

La configuración progresiva de estos rangos según el tamaño de instancia es fundamental para el desempeño del algoritmo DE. Los rangos más amplios en instancias grandes permiten mayor exploración, evitando convergencia prematura en espacios complejos con múltiples óptimos locales. Por otro lado, los rangos más acotados en instancias pequeñas aceleran la convergencia sin sacrificar calidad, aprovechando la menor complejidad del problema. Esta estratificación facilita la calibración automática mediante DE y garantiza la replicabilidad de los experimentos, permitiendo que el algoritmo híbrido se adapte eficientemente a diferentes escalas del VRP-TW.
\subsubsection{Representación de individuos}

En el contexto del DE, cada individuo de la población no representa una solución directa del problema VRP-TW, sino una configuración completa de los parámetros que controlan el comportamiento de las metaheurísticas ACO y SA. Es decir, un individuo codifica cómo se ejecutarán los algoritmos de optimización, incluyendo aspectos como la importancia relativa de la información heurística, la cantidad de agentes exploradores, el número de iteraciones y las estrategias de enfriamiento de SA.

Esta representación se realiza mediante un vector de parámetros reales de dimensión $D = 12$:

\[
	\mathbf{x}_i =
	[\alpha, \beta, \gamma, \rho, nh, \%h, niter\_ACO, T_0, T_f, \alpha_{cool}, fc, niter\_SA]
\]

donde cada componente controla un aspecto específico de las metaheurísticas:

\begin{itemize}
	\item $\alpha, \beta, \gamma, \rho$: parámetros de ACO que determinan el balance entre exploración y explotación, la importancia de feromonas, heurística de distancia y factibilidad temporal.
	\item $nh$: número de hormigas (agentes exploradores) en ACO.
	\item $\%h$: porcentaje de hormigas respecto al total de número de hormigas.
	\item $niter\_ACO$: número de iteraciones del ACO.
	\item $T_0, T_f$: temperaturas inicial y final de SA.
	\item $\alpha_{cool}$: factor de enfriamiento de SA.
	\item $fc$: factor de control de SA que modula la aceptación de soluciones subóptimas.
	\item $niter\_SA$: número de iteraciones de SA.
\end{itemize}

La existencia de individuos en el DE permite que el algoritmo explore de manera automática el espacio de parámetros, buscando combinaciones que generen mejores soluciones al VRP-TW. En otras palabras, cada individuo es una ``receta'' de cómo se ejecutará ACO+SA, y la población evoluciona para descubrir la configuración más efectiva para cada instancia.

Cada componente del vector está acotada dentro de rangos específicos $[min_j, max_j]$, que dependen del tamaño de la instancia (pequeña, mediana o grande), asegurando que los valores generados sean factibles y coherentes con el problema a resolver, y evitando configuraciones que puedan producir resultados inestables o poco eficientes.

\subsubsection{Función de Aptitud}

La función de aptitud evalúa la calidad de cada individuo, representado por un vector de parámetros, mediante la ejecución del algoritmo híbrido ACO+SA. Su propósito es cuantificar el desempeño de cada configuración de parámetros para determinar qué tan efectiva resulta en la resolución del VRP-TW.

El proceso de evaluación se desarrolla conforme a los siguientes pasos:

\begin{enumerate}
	\item Recibir un individuo $x_i$ que representa una configuración específica de parámetros del modelo.
	\item Inicializar las estructuras del problema (matrices de distancias, visibilidad, feromonas y ventanas de tiempo) de acuerdo con los valores contenidos en $x_i$.
	\item Ejecutar el algoritmo ACO utilizando los parámetros $\alpha$, $\beta$, $\rho$, $\gamma$, número de hormigas y número de iteraciones asociados al individuo $x_i$, generando una solución inicial de rutas.
	\item Aplicar el algoritmo SA con sus respectivos parámetros ($T_0$, $T_f$, $\alpha_{\text{cool}}$, factor de control y número de iteraciones) para mejorar las rutas obtenidas por ACO.
	\item Calcular el \textit{fitness} del individuo a partir del costo total de las rutas finales, recopilando la información necesaria para su evaluación.
\end{enumerate}

\subsubsection{Definición de la Función de Aptitud}

La función de aptitud se define a partir de la función objetivo del VRP-TW como:

\begin{equation}
	f(\mathbf{x}_i) = \text{Costo}_{\text{total}}
\end{equation}

donde:
\begin{itemize}
	\item $\text{Costo}_{\text{total}}$ representa la distancia total recorrida por todos los vehículos en la solución generada.
\end{itemize}

\textbf{Objetivo:} Minimizar $f(\mathbf{x}_i)$, es decir, encontrar la configuración de parámetros que produzca el menor costo total de rutas, cumpliendo las restricciones impuestas por el VRP-TW.

Cada evaluación de la función de aptitud implica ejecutar de forma completa el proceso híbrido ACO $\rightarrow$ SA, lo cual constituye el componente de mayor costo computacional dentro del algoritmo evolutivo diferencial (DE). Por este motivo, los valores del tamaño de población y del número de generaciones deben seleccionarse cuidadosamente para lograr un equilibrio entre precisión y tiempo de ejecución.

\subsubsection{Parámetros del Algoritmo Evolutivo Diferencial}

El DE requiere configurar cuatro parámetros principales que controlan su comportamiento y rendimiento:

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|>{\raggedright\arraybackslash}p{7cm}|}
		\hline
		\textbf{Parámetro}           & \textbf{Valor} & \textbf{Descripción}                                                                                                                                                       \\
		\hline
		Tamaño de población ($NP$)   & 20--30         & Número de configuraciones de parámetros evaluadas en cada generación. Valores mayores aumentan la diversidad pero incrementan el costo computacional.                      \\
		\hline
		Número de generaciones ($G$) & 50--150        & Número de iteraciones del algoritmo evolutivo. Se ajusta según el tamaño de la instancia: 50--80 para instancias pequeñas, 80--120 para medianas, y 100--150 para grandes. \\
		\hline
		Factor de mutación ($F$)     & 0.5            & Controla la magnitud de la perturbación en el operador de mutación. Un valor de 0.5 proporciona un balance adecuado entre exploración y explotación.                       \\
		\hline
		Tasa de cruce ($CR$)         & 0.5            & Probabilidad de que cada componente del vector provenga del vector mutante durante la recombinación. Un valor de 0.5 garantiza igual influencia de ambos padres.           \\
		\hline
	\end{tabular}
	\caption{Parámetros del Algoritmo Evolutivo Diferencial}
\end{table}

\subsubsection{Criterio de parada}

El algoritmo DE finaliza su ejecución cuando se alcanza el número máximo de generaciones. Esto ocurre al completarse el número de generaciones $G$ especificado.

El criterio principal utilizado en la implementación es el número máximo de generaciones, garantizando que el algoritmo realice una exploración suficientemente exhaustiva del espacio de parámetros antes de retornar la mejor configuración encontrada.

Al finalizar, el algoritmo encuentra el individuo con el menor fitness de toda la ejecución, el cual representa la mejor configuración de parámetros para ACO y SA, además de la mejor ruta encontrada durante el proceso evolutivo.

\subsubsection{Pseudocódigo del Algoritmo Evolutivo Diferencial}

A continuación se presenta el pseudocódigo del algoritmo DE implementado para la calibración automática de parámetros:

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{Evolución Diferencial para Calibración de Parámetros en VRP-TW}
		\label{alg:de_vrptw}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}
		\KwIn{$NP$ (población), $G$ (generaciones), instancia VRP-TW}
		\KwOut{Mejor individuo con parámetros óptimos}
		\textbf{Inicialización:}\\
		Leer instancia; Inicializar matrices (distancias, visibilidad, feromonas, ventanas).\\
		Definir rangos según tamaño de instancia.\\
		\textbf{para} $i=1$ \textbf{hasta} $i=NP$ \textbf{hacer}\\
		\hspace{1em} Generar objetivo[$i$] aleatorio; Evaluar con ACO+SA.\\
		\textbf{fin para}\\
		MejorIndividuo $\gets$ individuo con menor fitness.\\
		\textbf{Evolución:}\\
		\textbf{para} $g=1$ \textbf{hasta} $g=G$ \textbf{hacer}\\
		\hspace{1em} \textbf{para} $i=1$ \textbf{hasta} $i=NP$ \textbf{hacer} \textit{(Mutación)}\\
		\hspace{2em} Seleccionar $r_1, r_2, r_3$ distintos; Calcular ruidoso[$i$] con DE/rand/1.\\
		\hspace{2em} Limitar ruidoso[$i$] a rangos válidos.\\
		\hspace{1em} \textbf{fin para}\\
		\hspace{1em} \textbf{para} $i=1$ \textbf{hasta} $i=NP$ \textbf{hacer} \textit{(Recombinación)}\\
		\hspace{2em} Generar aleatorio $r$; prueba[$i$] $\gets$ objetivo[$i$] si $r \leq 0.5$, sino ruidoso[$i$].\\
		\hspace{1em} \textbf{fin para}\\
		\hspace{1em} \textbf{para} $i=1$ \textbf{hasta} $i=NP$ \textbf{hacer} \textit{(Evaluación)}\\
		\hspace{2em} Evaluar prueba[$i$] con ACO+SA.\\
		\hspace{2em} \textbf{si} fitness(prueba[$i$]) $<$ fitness(MejorIndividuo) \textbf{entonces} actualizar.\\
		\hspace{1em} \textbf{fin para}\\
		\hspace{1em} \textbf{para} $i=1$ \textbf{hasta} $i=NP$ \textbf{hacer} \textit{(Selección)}\\
		\hspace{2em} \textbf{si} fitness(prueba[$i$]) $<$ fitness(objetivo[$i$]) \textbf{entonces} objetivo[$i$] $\gets$ prueba[$i$].\\
		\hspace{1em} \textbf{fin para}\\
		\textbf{fin para}\\
		Retornar MejorIndividuo.\\
	\end{algorithm}
	\caption{Pseudocódigo del algoritmo de Evolución Diferencial (DE) aplicado al problema VRP-TW.}
	\label{fig:algoritmo_de_vrptw}
\end{figure}

\subsection{Construcción de rutas iniciales mediante Optimización por Colonia de Hormigas}

Una vez calibrados los parámetros mediante DE, la segunda etapa del enfoque híbrido consiste en construir soluciones factibles para el VRP-TW utilizando Optimización por Colonia de Hormigas (ACO). Este algoritmo bio-inspirado simula el comportamiento de las hormigas reales al buscar alimento, utilizando rastros de feromonas para encontrar rutas eficientes que minimicen la distancia total recorrida mientras respetan las restricciones de capacidad de los vehículos y las ventanas de tiempo de los clientes.

\subsubsection{Fundamentos del algoritmo ACO}

El algoritmo ACO se basa en tres componentes principales que guían la construcción probabilística de soluciones:

\begin{enumerate}
	\item \textbf{Información de feromonas ($\tau_{ij}$):} Representa el conocimiento acumulado sobre qué conexiones entre clientes han formado parte de buenas soluciones en iteraciones previas. Mayor nivel de feromona indica rutas prometedoras.

	\item \textbf{Información heurística ($\eta_{ij}$):} Proporciona conocimiento a priori sobre la calidad de las conexiones, típicamente basado en la distancia euclidiana entre clientes. Se define como $\eta_{ij} = 1/d_{ij}$, favoreciendo clientes cercanos.

	\item \textbf{Información de ventanas de tiempo ($\omega_{ij}$):} Componente adicional específico para VRP-TW que considera la factibilidad temporal de visitar el cliente $j$ después del cliente $i$. Se calcula como $\omega_{ij} = 1/l_j$, donde $l_j$ es el límite superior de la ventana de tiempo del cliente $j$.
\end{enumerate}

\subsubsection{Construcción probabilística de rutas}

Cada hormiga artificial construye una solución completa siguiendo una estrategia constructiva voraz aleatorizada. El proceso inicia desde el depósito y en cada paso, la hormiga $k$ selecciona el siguiente cliente $j$ a visitar desde su posición actual $i$ con una probabilidad dada por:

\begin{equation}
	p_{ij}^k = \frac{[\tau_{ij}]^\alpha \cdot [\eta_{ij}]^\beta \cdot [\omega_{ij}]^\gamma}{\sum_{l \in N_i^k} [\tau_{il}]^\alpha \cdot [\eta_{il}]^\beta \cdot [\omega_{il}]^\gamma}
\end{equation}

donde:
\begin{itemize}
	\item $N_i^k$ es el conjunto de clientes factibles que la hormiga $k$ puede visitar desde $i$
	\item $\alpha$ controla la influencia de la información de feromonas
	\item $\beta$ controla la influencia de la información heurística (distancia)
	\item $\gamma$ controla la influencia de las ventanas de tiempo
\end{itemize}

Un cliente $j$ se considera factible si cumple simultáneamente:
\begin{itemize}
	\item No ha sido visitado previamente en la ruta actual
	\item La capacidad del vehículo no se excede: $q_{\text{actual}} + d_j \leq Q$
	\item La ventana de tiempo puede satisfacerse: $t_{\text{llegada}} \leq l_j$
	\item El vehículo puede regresar al depósito después de servir al cliente $j$ dentro de su límite temporal
\end{itemize}

En el siguiente psudocodigo detalla el proceso de verificación de factibilidad para determinar qué clientes pueden ser visitados desde la posición actual del vehículo.

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{Cálculo de Clientes Factibles}
		\label{alg:clientes_factibles}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}

		\KwIn{Cliente origen, vehículo $v$, lista tabú $T$, configuración VRP}
		\KwOut{Conjunto de clientes factibles}

		Candidatos $\gets \emptyset$.\\
		\textbf{para} $i=1$ \textbf{hasta} $n-1$ \textbf{hacer} \textit{(excluir depósito)}\\
		\hspace{1em} \textbf{si} $i \notin T$ \textbf{entonces}\\
		\hspace{2em} $t_{\text{viaje}} \gets d_{\text{origen},i} / v.\text{velocidad}$.\\
		\hspace{2em} $t_{\text{llegada}} \gets v.t_{\text{actual}} + t_{\text{viaje}}$.\\
		\hspace{2em} $t_{\text{retorno}} \gets d_{i,0} / v.\text{velocidad}$.\\
		\hspace{2em} $t_{\text{total}} \gets t_{\text{llegada}} + s_i + t_{\text{retorno}}$.\\

		\hspace{2em} \textbf{si} $t_{\text{llegada}} \geq e_i$ y $t_{\text{llegada}} \leq l_i$ \textbf{entonces}\\
		\hspace{3em} \textbf{si} $v.q + d_i \leq v.Q$ \textbf{entonces}\\
		\hspace{4em} \textbf{si} $t_{\text{total}} \leq l_0$ \textbf{entonces}\\
		\hspace{5em} Candidatos $\gets$ Candidatos $\cup \{i\}$.\\
		\hspace{4em} \textbf{fin si}\\
		\hspace{3em} \textbf{fin si}\\
		\hspace{2em} \textbf{fin si}\\
		\hspace{1em} \textbf{fin si}\\
		\textbf{fin para}\\
		Retornar Candidatos.\\

	\end{algorithm}
	\caption{Pseudocódigo de verificación de clientes factibles en ACO.}
	\label{fig:algoritmo_clientes_factibles}
\end{figure}

El pseudocódigo \ref{alg:clientes_factibles} determina qué clientes pueden ser visitados desde la posición actual del vehículo considerando las restricciones del problema. Para cada cliente no visitado, se calcula el tiempo de viaje, la hora estimada de llegada, el tiempo de servicio y el retorno al depósito. Un cliente se considera factible si puede ser atendido dentro de su ventana de tiempo, no excede la capacidad del vehículo y permite regresar al depósito antes del límite temporal. El conjunto final de clientes factibles se utiliza posteriormente en el proceso de construcción de la solución para guiar la selección probabilística del siguiente destino.

\subsubsection{Gestión de restricciones temporales}

El manejo de las ventanas de tiempo es crítico en el VRP-TW. Para cada cliente $j$ visitado, se calculan:

\begin{equation}
	t_{\text{llegada}}^j = t_{\text{salida}}^i + \frac{d_{ij}}{v}
	\label{eq:tiempo_llegada}
\end{equation}

\begin{equation}
	t_{\text{inicio\_servicio}}^j = \max(t_{\text{llegada}}^j, e_j)
	\label{eq:inicio_servicio}
\end{equation}

\begin{equation}
	t_{\text{salida}}^j = t_{\text{inicio\_servicio}}^j + s_j
	\label{eq:salida_cliente}
\end{equation}

La ecuación \ref{eq:tiempo_llegada} calcula el tiempo de llegada del vehículo al cliente $j$, considerando el tiempo de salida del cliente anterior y el tiempo de viaje entre ambos puntos.
La ecuación \ref{eq:inicio_servicio} determina el instante en que comienza la atención al cliente, contemplando posibles tiempos de espera cuando el vehículo arriba antes del inicio de la ventana de tiempo.
Finalmente, la ecuación \ref{eq:salida_cliente} establece el momento de salida del cliente, sumando al inicio del servicio el tiempo de atención requerido.
En conjunto, estas expresiones permiten verificar la factibilidad temporal de las rutas y asegurar el cumplimiento de las restricciones de ventanas de tiempo en el VRP-TW.

\subsubsection{Proceso de construcción de soluciones y gestión de flota}

En el algoritmo ACO aplicado al VRP-TW, cada hormiga construye soluciones factibles mediante un proceso probabilístico que combina la selección guiada por feromonas con la verificación de restricciones temporales y de capacidad. Además, se incorpora un mecanismo dinámico de gestión de flota para asignar nuevos vehículos cuando no existan clientes factibles desde la posición actual.

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{Construcción de Solución por una Hormiga}
		\label{alg:construccion_solucion}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}

		\KwIn{Matrices $\tau, \eta, \omega$, parámetros $\alpha, \beta, \gamma$, configuración VRP}
		\KwOut{Solución completa (conjunto de rutas)}

		Inicializar lista tabú $T \gets \{0\}$ (depósito visitado).\\
		Crear vehículo inicial en el depósito: $v_1$ con carga $q=0$, tiempo $t=0$.\\
		posición $\gets 0$ (depósito), Rutas $\gets \emptyset$.\\

		\textbf{mientras} $|T| <$ número total de clientes \textbf{hacer}\\
		\hspace{1em} Candidatos $\gets \emptyset$.\\
		\hspace{1em} \textbf{mientras} Candidatos $= \emptyset$ y $t <$ límite temporal del depósito \textbf{hacer}\\
		\hspace{2em} Candidatos $\gets$ CalcularClientesFactibles(posición, $v$, $T$).\\
		\hspace{2em} \textbf{si} Candidatos $= \emptyset$ \textbf{entonces}\\
		\hspace{3em} $t \gets t + 1$ \textit{(avance temporal)}.\\
		\hspace{2em} \textbf{fin si}\\
		\hspace{1em} \textbf{fin mientras}\\

		\hspace{1em} \textbf{si} Candidatos $= \emptyset$ \textbf{entonces}\\
		\hspace{2em} Cerrar ruta actual: Agregar retorno al depósito.\\
		\hspace{2em} \textbf{si} Vehículos usados $<$ Vehículos máximos \textbf{entonces}\\
		\hspace{3em} Crear nuevo vehículo en el depósito.\\
		\hspace{3em} $q \gets 0$, $t \gets 0$, posición $\gets 0$.\\
		\hspace{2em} \textbf{si no}\\
		\hspace{3em} Reiniciar hormiga completamente.\\
		\hspace{2em} \textbf{fin si}\\
		\hspace{1em} \textbf{si no}\\
		\hspace{2em} \textbf{para cada} cliente $j \in$ Candidatos \textbf{hacer}\\
		\hspace{3em} $p_j \gets \frac{[\tau_{\text{posición},j}]^\alpha \cdot [\eta_{\text{posición},j}]^\beta \cdot [\omega_{\text{posición},j}]^\gamma}{\sum_{l \in \text{Candidatos}} [\tau_{\text{posición},l}]^\alpha \cdot [\eta_{\text{posición},l}]^\beta \cdot [\omega_{\text{posición},l}]^\gamma}$.\\
		\hspace{2em} \textbf{fin para}\\
		\hspace{2em} Seleccionar cliente $j^*$ según distribución de probabilidad $\{p_j\}$.\\
		\hspace{2em} Agregar $j^*$ a ruta actual, $T \gets T \cup \{j^*\}$.\\
		\hspace{2em} Actualizar: $q \gets q + d_{j^*}$, $t \gets t + t_{\text{viaje}} + s_{j^*}$.\\
		\hspace{2em} posición $\gets j^*$.\\
		\hspace{1em} \textbf{fin si}\\
		\textbf{fin mientras}\\
		Cerrar última ruta: Agregar retorno al depósito.\\
		Retornar Rutas.\\

	\end{algorithm}
	\caption{Pseudocódigo del proceso de construcción de una solución completa por una hormiga.}
	\label{fig:algoritmo_construccion_solucion}
\end{figure}

El pseudocódigo \ref{alg:construccion_solucion} muestra el procedimiento mediante el cual una hormiga construye una solución completa para el VRP-TW. En cada iteración, selecciona probabilísticamente el siguiente cliente considerando la información de feromonas, heurística y factibilidad temporal. Cuando no hay clientes accesibles, se aplica un avance temporal hasta habilitar nuevas opciones o cerrar la ruta actual, asignando un nuevo vehículo si el límite no ha sido alcanzado. Este proceso asegura la generación de soluciones coherentes y factibles que respetan las restricciones de capacidad, tiempo y número de vehículos.


\subsubsection{Evaluación de la función objetivo}

Una vez construida la solución, se evalúa su calidad mediante el cálculo de la distancia total recorrida por todos los vehículos. Este valor representa el fitness de la solución y permite comparar la eficiencia de las rutas generadas por cada hormiga.

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{Evaluación de la función objetivo}
		\label{alg:evaluacion_fitness}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}

		\KwIn{Solución (conjunto de rutas), matriz de distancias $D$}
		\KwOut{Fitness total de la solución}

		FitnessTotal $\gets 0$.\\
		\textbf{para cada} vehículo $v$ en la Solución \textbf{hacer}\\
		\hspace{1em} FitnessVehículo $\gets 0$.\\
		\hspace{1em} Ruta $\gets$ obtener ruta del vehículo $v$.\\
		\hspace{1em} \textbf{para} $k=0$ \textbf{hasta} $|$Ruta$|-2$ \textbf{hacer}\\
		\hspace{2em} $i \gets$ Ruta[$k$], $j \gets$ Ruta[$k+1$].\\
		\hspace{2em} FitnessVehículo $\gets$ FitnessVehículo $+ D_{ij}$.\\
		\hspace{1em} \textbf{fin para}\\
		\hspace{1em} $v.$fitness $\gets$ FitnessVehículo.\\
		\hspace{1em} FitnessTotal $\gets$ FitnessTotal $+$ FitnessVehículo.\\
		\textbf{fin para}\\
		Retornar FitnessTotal.\\

	\end{algorithm}
	\caption{Pseudocódigo del cálculo del fitness total de una solución.}
	\label{fig:algoritmo_evaluacion_fitness}
\end{figure}

El algoritmo \ref{alg:evaluacion_fitness} calcula el fitness total de la solución sumando las distancias recorridas por cada vehículo. Para cada ruta, se acumulan las distancias entre clientes consecutivos, incluyendo los trayectos desde y hacia el depósito. Este valor cuantifica la eficiencia global de la solución, siendo menor el fitness cuanto más cortas sean las rutas generadas.

\subsubsection{Actualización de feromonas}

Tras cada iteración, las feromonas se actualizan para reflejar la calidad de las soluciones construidas por las hormigas. Este proceso combina tres fases: evaporación, depósito y refuerzo elitista, que en conjunto equilibran la exploración de nuevas rutas y la explotación de las soluciones más prometedoras.

\paragraph{Evaporación de feromonas.}
Este mecanismo reduce uniformemente los niveles de feromona para evitar la saturación de ciertos caminos y fomentar la exploración de alternativas. Se define mediante la ecuación \ref{eq:evaporacion_feromona}:

\begin{equation}
	\tau_{ij} \leftarrow (1 - \rho) \cdot \tau_{ij}, \quad \forall (i,j)
	\label{eq:evaporacion_feromona}
\end{equation}

donde $\rho \in [0,1]$ es la tasa de evaporación. Un valor alto de $\rho$ acelera la pérdida de feromonas, promoviendo la diversidad, mientras que un valor bajo intensifica la explotación de rutas ya exploradas.

\paragraph{Depósito de feromonas.}
\raggedright
Las hormigas que obtienen las mejores soluciones —definidas como el conjunto élite— depositan feromonas sobre las aristas que conforman sus rutas. Este refuerzo se modela en la ecuación \ref{eq:deposito_feromona}:

\begin{equation}
	\tau_{ij} \leftarrow \tau_{ij} + \sum_{k \in \text{Elite}} \Delta\tau_{ij}^k
	\label{eq:deposito_feromona}
\end{equation}

donde la cantidad de feromona añadida por cada hormiga $k$ se determina mediante la ecuación \ref{eq:delta_tau}:

\begin{equation}
	\Delta\tau_{ij}^k =
	\begin{cases}
		\dfrac{1}{L_k}, & \text{si la hormiga } k \text{ usa la arista } (i,j) \\
		0,              & \text{en otro caso}
	\end{cases}
	\label{eq:delta_tau}
\end{equation}

Aquí, $L_k$ representa el costo total (distancia recorrida) de la solución de la hormiga $k$. En consecuencia, las soluciones más cortas (menor $L_k$) contribuyen con una mayor cantidad de feromona, orientando a futuras hormigas hacia rutas más eficientes.

\paragraph{Refuerzo elitista.}
Finalmente, se aplica un refuerzo adicional a la mejor solución global encontrada hasta el momento, modelado en la ecuación \ref{eq:refuerzo_elitista}:

\begin{equation}
	\tau_{ij} \leftarrow \tau_{ij} + 2 \cdot \frac{1}{L_{best}}, \quad \forall (i,j) \in \text{MejorRuta}
	\label{eq:refuerzo_elitista}
\end{equation}

donde $L_{best}$ corresponde al costo total de la mejor solución histórica. El factor multiplicativo (en este caso, 2) duplica la influencia de dicha solución sobre la actualización global, intensificando su preservación.

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{Pseudocódigo de la Actualización de Feromonas}
		\label{alg:actualizacion_feromonas}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}

		\KwIn{Matriz $\tau$, tasa $\rho$, hormigas elite, mejor solución global}
		\KwOut{Matriz $\tau$ actualizada}

		\textbf{Evaporación:}\\
		\For{$i=0$ \KwTo $n-1$}{
			\For{$j=0$ \KwTo $n-1$}{
				\If{$i \neq j$}{
					$\tau_{ij} \gets (1 - \rho) \cdot \tau_{ij}$.
				}
			}
		}

		\textbf{Depósito de feromonas:}\\
		\ForEach{hormiga $k$ en Elite}{
			$\Delta\tau \gets 1 / L_k$\\
			\ForEach{arista $(i,j)$ en la ruta de $k$}{
				$\tau_{ij} \gets \tau_{ij} + \Delta\tau$\\
				$\tau_{ji} \gets \tau_{ji} + \Delta\tau$
			}
		}

		\textbf{Refuerzo elitista:}\\
		$\Delta\tau_{best} \gets 2 / L_{best}$\\
		\ForEach{arista $(i,j)$ en MejorRuta}{
			$\tau_{ij} \gets \tau_{ij} + \Delta\tau_{best}$\\
			$\tau_{ji} \gets \tau_{ji} + \Delta\tau_{best}$
		}

		\Return{$\tau$}
	\end{algorithm}
	\caption{Pseudocódigo del proceso de actualización de feromonas en tres fases: evaporación, depósito y refuerzo elitista.}
	\label{fig:algoritmo_actualizacion_feromonas}
\end{figure}

El pseudocódigo \ref{alg:actualizacion_feromonas} muestra el procedimiento completo de actualización de la matriz de feromonas. Este proceso regula el equilibrio entre exploración y explotación, garantizando que el sistema mantenga la diversidad de soluciones mientras converge hacia rutas de alta calidad.


\subsubsection{Criterio de factibilidad}

Una solución se considera factible si:
\begin{itemize}
	\item Todos los clientes son visitados exactamente una vez
	\item Ninguna ruta excede la capacidad del vehículo
	\item Todas las ventanas de tiempo se respetan estrictamente
	\item Cada ruta inicia y termina en el depósito
	\item El número de vehículos utilizados no excede el máximo disponible
\end{itemize}

El algoritmo garantiza la factibilidad mediante la construcción de listas de candidatos que verifican todas estas restricciones antes de la selección probabilística.

\subsubsection{Pseudocódigo del ACO integrado con Recocido Simulado}

A continuación se presenta la estructura general del algoritmo ACO aplicado al VRP-TW.

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{ACO integrado con Recocido Simulado para VRP-TW}
		\label{alg:aco_vrptw}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}

		\KwIn{Parámetros $\alpha, \beta, \gamma, \rho$, número de hormigas $m$, iteraciones $n_{iter}$, porcentaje élite $p_{elite}$}
		\KwOut{Mejor solución encontrada}

		Inicializar matrices de feromonas, visibilidad e información temporal.\\
		MejorSoluciónGlobal $\gets$ NULL, MejorCostoGlobal $\gets \infty$.\\

		\textbf{para} $iter=1$ \textbf{hasta} $n_{iter}$ \textbf{hacer}\\
		\hspace{1em} \textbf{para} $k=1$ \textbf{hasta} $m$ \textbf{hacer}\\
		\hspace{2em} Solución$_k$ $\gets$ ConstruirSolución($\alpha, \beta, \gamma$).\\
		\hspace{2em} Costo$_k$ $\gets$ EvaluarFitness(Solución$_k$).\\
		\hspace{1em} \textbf{fin para}\\
		\hspace{1em} OrdenarHormigas por Costo ascendente.\\
		\hspace{1em} Elite $\gets$ primeras $\lceil m \times p_{elite} \rceil$ hormigas.\\
		\hspace{1em} \textbf{para cada} hormiga $k \in$ Elite \textbf{hacer}\\
		\hspace{2em} Solución$_k$ $\gets$ AplicarRecocidoSimulado(Solución$_k$).\\
		\hspace{2em} Costo$_k$ $\gets$ EvaluarFitness(Solución$_k$).\\
		\hspace{2em} \textbf{si} Costo$_k$ $<$ MejorCostoGlobal \textbf{entonces}\\
		\hspace{3em} MejorSoluciónGlobal $\gets$ Solución$_k$.\\
		\hspace{3em} MejorCostoGlobal $\gets$ Costo$_k$.\\
		\hspace{2em} \textbf{fin si}\\
		\hspace{1em} \textbf{fin para}\\
		\hspace{1em} ActualizarFeromonas(Elite, MejorSoluciónGlobal, $\rho$).\\
		\hspace{1em} \textbf{si} $iter < n_{iter}$ \textbf{entonces} ReiniciarHormigas().\\
		\textbf{fin para}\\
		Retornar MejorSoluciónGlobal.\\
	\end{algorithm}
	\caption{Pseudocódigo del ACO con Recocido Simulado para VRP-TW.}
	\label{fig:algoritmo_aco_principal}
\end{figure}

El pseudocódigo \ref{fig:algoritmo_aco_principal} describe el flujo completo del proceso de optimización. Las hormigas generan soluciones basadas en la información de feromonas y la heurística; las mejores son refinadas mediante Recocido Simulado. Finalmente, la actualización de feromonas refuerza las rutas más prometedoras, guiando la búsqueda hacia soluciones de mayor calidad.

\subsection{Refinamiento de rutas mediante Recocido Simulado}

La tercera y última etapa del enfoque híbrido consiste en refinar las soluciones generadas por ACO mediante Recocido Simulado (SA), una metaheurística de búsqueda local que permite escapar de óptimos locales a través de la aceptación probabilística de soluciones que empeoran temporalmente la función objetivo. SA recibe como entrada las mejores rutas construidas por ACO y aplica operadores de vecindad para explorar sistemáticamente el espacio de soluciones cercanas, buscando mejoras incrementales que reduzcan el costo total de las rutas mientras se mantiene la factibilidad.

\subsubsection{Fundamentos del algoritmo SA}

El algoritmo SA está inspirado en el proceso metalúrgico de recocido, donde un metal se calienta a alta temperatura y luego se enfría gradualmente para alcanzar un estado de mínima energía. En el contexto de optimización, la temperatura controla la probabilidad de aceptar soluciones deteriorantes, permitiendo escapar de óptimos locales en etapas tempranas (alta temperatura) y convergiendo hacia soluciones de alta calidad en etapas finales (baja temperatura).

Los componentes principales del algoritmo son:

\begin{itemize}
	\item \textbf{Temperatura inicial ($T_0$):} Valor alto que permite gran exploración inicial, aceptando movimientos deteriorantes con alta probabilidad.

	\item \textbf{Temperatura final ($T_f$):} Valor muy bajo que marca el fin del algoritmo, cuando prácticamente solo se aceptan mejoras. Se establece un umbral mínimo de $10^{-10}$ para evitar problemas numéricos.

	\item \textbf{Factor de enfriamiento ($\alpha_{\text{cool}}$):} Parámetro $\in (0,1)$ que controla la velocidad de descenso de temperatura según $T_{t+1} = \alpha_{\text{cool}} \cdot T_t$.

	\item \textbf{Iteraciones por nivel de temperatura ($n_{\text{iter}}$):} Número de iteraciones a realizar en cada nivel de temperatura antes de enfriar, permitiendo una exploración adecuada del vecindario.
\end{itemize}

\subsubsection{Operadores de vecindad adaptativos}

Para explorar el espacio de soluciones, SA implementa un conjunto de ocho operadores de vecindad especializados que modifican las rutas de manera controlada. La selección de operadores se realiza de forma \textbf{adaptativa} según dos criterios fundamentales: el tamaño de la instancia (número de clientes) y el número de vehículos en la solución actual. Esta estrategia permite ajustar dinámicamente la exploración del espacio de búsqueda según las características específicas del problema.

\paragraph{Clasificación de operadores:}

Los operadores se dividen en dos categorías principales:

\textbf{Operadores intra-ruta:} Modifican la secuencia de clientes dentro de una misma ruta:
\begin{itemize}
	\item \textbf{Swap intra-ruta:} Intercambia las posiciones de dos clientes dentro de la misma ruta.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador Swap Intra-Ruta}
			      \label{alg:swap_intra}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar vehículo aleatorio con $\geq 2$ clientes.\\
			      Seleccionar dos posiciones distintas $i, j$ en la ruta.\\
			      Intercambiar clientes en posiciones $i$ y $j$.\\
			      \textbf{si} verificar\_restricciones($s'$) \textbf{entonces} retornar $s'$ \textbf{si no} revertir.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador Swap Intra-Ruta.}
	      \end{figure}

	\item \textbf{2-opt:} Invierte un segmento de la ruta, eliminando cruces geométricos.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador 2-opt}
			      \label{alg:2opt}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar vehículo con $\geq 3$ clientes.\\
			      Seleccionar dos posiciones $k < m$ que definan un segmento.\\
			      Invertir el orden de clientes en el segmento $[k, m]$.\\
			      \textbf{si} verificar\_restricciones($s'$) \textbf{entonces} retornar $s'$ \textbf{si no} revertir.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador 2-opt.}
	      \end{figure}

	\item \textbf{Or-opt:} Reubica un segmento de 1–3 clientes consecutivos dentro de la misma ruta.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador Or-opt}
			      \label{alg:or_opt}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar vehículo con $\geq 3$ clientes.\\
			      Seleccionar segmento de 1–3 clientes consecutivos.\\
			      Eliminar segmento; Seleccionar nueva posición no solapada.\\
			      Insertar segmento en nueva posición.\\
			      \textbf{si} verificar\_restricciones($s'$) \textbf{entonces} retornar $s'$ \textbf{si no} restaurar.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador Or-opt.}
	      \end{figure}
\end{itemize}

\textbf{Operadores inter-ruta:} Transfieren clientes o segmentos entre diferentes rutas:
\begin{itemize}
	\item \textbf{Swap inter-ruta:} Intercambia un cliente de una ruta con un cliente de otra ruta.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador Swap Inter-Ruta}
			      \label{alg:swap_inter}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar dos vehículos distintos con $\geq 1$ cliente cada uno.\\
			      Seleccionar posición $i$ en vehículo 1 y posición $j$ en vehículo 2.\\
			      Intercambiar clientes entre ambas posiciones.\\
			      \textbf{si} verificar\_restricciones(vehículo 1) y verificar\_restricciones(vehículo 2) \textbf{entonces}\\
			      \hspace{1em} retornar $s'$ \textbf{si no} revertir.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador Swap Inter-Ruta.}
	      \end{figure}

	\item \textbf{Reinserción intra-inter:} Extrae un cliente y lo reinserta en otra posición, ya sea en la misma ruta o en una ruta diferente.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador Reinserción Intra-Inter}
			      \label{alg:reinsercion}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar vehículo origen con $\geq 1$ cliente.\\
			      Seleccionar cliente $c$ y eliminarlo de su posición.\\
			      Seleccionar vehículo destino y posición de inserción.\\
			      Insertar cliente $c$ en nueva posición.\\
			      \textbf{si} verificar\_restricciones(ambos vehículos) \textbf{entonces} retornar $s'$ \textbf{si no} revertir.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador Reinserción Intra-Inter.}
	      \end{figure}

	\item \textbf{2.5-opt:} Mueve un segmento de 1–2 clientes desde un vehículo origen hacia un vehículo destino.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador 2.5-opt}
			      \label{alg:2_5_opt}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar vehículo origen con $\geq 2$ clientes.\\
			      Seleccionar segmento de tamaño 1–2 clientes.\\
			      Eliminar segmento del origen; Seleccionar vehículo destino.\\
			      Insertar segmento en posición aleatoria del destino.\\
			      \textbf{si} verificar\_restricciones(ambos) \textbf{entonces} retornar $s'$ \textbf{si no} restaurar.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador 2.5-opt.}
	      \end{figure}

	\item \textbf{Cross-exchange:} Intercambia segmentos de 1–2 clientes entre dos vehículos diferentes.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador Cross-exchange}
			      \label{alg:cross_exchange}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar dos vehículos distintos con $\geq 1$ cliente cada uno.\\
			      Seleccionar segmentos de tamaño 1–2 en cada vehículo.\\
			      Eliminar ambos segmentos; Intercambiar posiciones.\\
			      Insertar segmentos en vehículos opuestos.\\
			      \textbf{si} verificar\_restricciones(ambos) \textbf{entonces} retornar $s'$ \textbf{si no} restaurar.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador Cross-exchange.}
	      \end{figure}

	\item \textbf{Relocate-chain:} Reubica una cadena de 2–4 clientes consecutivos desde un vehículo origen hacia un vehículo destino.

	      \begin{figure}[H]
		      \centering
		      \begin{algorithm}[H]
			      \caption{Operador Relocate-chain}
			      \label{alg:relocate_chain}
			      \SetAlgoLined
			      \SetAlFnt{\footnotesize}

			      \KwIn{Solución $s$, configuración VRP}
			      \KwOut{Solución vecina $s'$ o rechazo del movimiento}

			      Seleccionar vehículo origen con $\geq 2$ clientes.\\
			      Seleccionar cadena de 2–4 clientes consecutivos (máx. 50\% de la ruta).\\
			      Eliminar cadena del origen; Seleccionar vehículo destino.\\
			      Insertar cadena completa en destino.\\
			      \textbf{si} verificar\_restricciones(ambos) \textbf{entonces} retornar $s'$ \textbf{si no} restaurar.\\
		      \end{algorithm}
		      \caption{Pseudocódigo del operador Relocate-chain.}
	      \end{figure}
\end{itemize}

\paragraph{Estrategia adaptativa de selección:}

La probabilidad de aplicar cada operador se ajusta dinámicamente según tres configuraciones basadas en el tamaño de la instancia:

\textbf{Instancias pequeñas ($n \leq 26$ clientes):}
\begin{itemize}
	\item \textit{Múltiples vehículos:} Se priorizan operadores inter-ruta intensivos (cross-exchange 25\%, relocate-chain 20\%, swap inter 20\%) para facilitar consolidación de rutas y redistribución de cargas.
	\item \textit{Un solo vehículo:} Se enfatiza la optimización intra-ruta con relocate-chain (30\%), 2.5-opt (25\%) y reinserción (20\%) para mejorar la secuencia de visitas.
\end{itemize}

\textbf{Instancias medianas ($26 < n \leq 51$ clientes):}
\begin{itemize}
	\item \textit{Múltiples vehículos:} Balance entre operadores inter-ruta (cross-exchange 30\%, relocate-chain 25\%, swap inter 20\%) e intra-ruta para mantener diversificación.
	\item \textit{Un solo vehículo:} Mayor peso en relocate-chain (35\%), 2.5-opt (30\%) y reinserción (20\%) para optimización intensiva de la ruta única.
\end{itemize}

\textbf{Instancias grandes ($n > 51$ clientes):}
\begin{itemize}
	\item \textit{Múltiples vehículos:} Dominio de relocate-chain (35\%) y cross-exchange (30\%) para manejar la complejidad combinatoria, complementado con swap inter (20\%).
	\item \textit{Un solo vehículo:} Fuerte énfasis en relocate-chain (40\%) y 2.5-opt (35\%) con operadores adicionales en menor proporción.
\end{itemize}

\subsubsection{Criterio de aceptación de Metropolis}

En cada iteración, SA genera una solución vecina $s'$ a partir de la solución actual $s$ aplicando probabilísticamente uno de los ocho operadores de vecindad según la estrategia adaptativa. La decisión de aceptar o rechazar $s'$ se basa en el \textbf{criterio de Metropolis}:

\begin{equation}
	\text{Aceptar } s' = \begin{cases}
		\text{Sí} & \text{si } f(s') < f(s) - \epsilon \text{ (siempre aceptar mejoras)}                                           \\
		\text{Sí} & \text{si } \Delta f > \epsilon, T > 10^{-10} \text{ y } r < e^{-\Delta f / T} \text{ (aceptar empeoramientos)} \\
		\text{No} & \text{en otro caso}
	\end{cases}
\end{equation}

donde:
\begin{itemize}
	\item $\Delta f = f(s') - f(s)$ es la diferencia de costo
	\item $T$ es la temperatura actual
	\item $\epsilon = 10^{-6}$ es una tolerancia numérica para comparaciones de punto flotante
	\item $r$ es un número aleatorio uniforme en $[0,1]$
\end{itemize}

La probabilidad de aceptar un empeoramiento es mayor cuando:
\begin{itemize}
	\item La temperatura $T$ es alta (exploración inicial)
	\item La diferencia de costo $\Delta f$ es pequeña (empeoramiento leve)
\end{itemize}

\subsubsection{Esquema de enfriamiento}

La temperatura se reduce gradualmente siguiendo un esquema de \textbf{enfriamiento geométrico}:

\begin{equation}
	T_{t+1} = \alpha_{\text{cool}} \cdot T_t
\end{equation}

con $\alpha_{\text{cool}} \in [0.95, 0.995]$ según el tamaño de la instancia. En cada nivel de temperatura $T_t$, se realizan $n_{\text{iter}}$ iteraciones antes de enfriar, permitiendo una exploración adecuada del vecindario antes de intensificar la búsqueda.

El algoritmo finaliza cuando la temperatura alcanza $T_f$ o cuando $T < 10^{-10}$ (protección numérica).

\subsubsection{Manejo de factibilidad y limpieza de vehículos}

Dado que los operadores de vecindad pueden generar soluciones infactibles que violan restricciones de capacidad o ventanas de tiempo, se implementan mecanismos de validación rigurosos descritos en el algoritmo \ref{fig:verificacion_restricciones}.

% \begin{figure}[H]
% 	\centering
% 	\begin{algorithm}[H]
% 		\caption{Verificación de Restricciones y Factibilidad}
% 		\label{alg:verificacion_restricciones}
% 		\SetAlgoLined
% 		\SetAlFnt{\footnotesize}

% 		\KwIn{Vehículo $v$, configuración VRP, matriz de distancias $D$}
% 		\KwOut{true si factible, false en caso contrario}

% 		\textbf{Inicialización:}\\
% 		$t \gets 0$ (tiempo acumulado), $q \gets 0$ (capacidad acumulada).\\
% 		clienteAnterior $\gets$ NULL.\\

% 		\textbf{Recorrido de la ruta:}\\
% 		\textbf{para cada} nodo en $v.$ruta \textbf{hacer}\\
% 		\hspace{1em} cliente $\gets$ nodo.cliente.\\

% 		\hspace{1em} \textbf{si} clienteAnterior $\neq$ NULL \textbf{entonces}\\
% 		\hspace{2em} \textbf{si} clienteAnterior $\neq 0$ \textbf{entonces}\\
% 		\hspace{3em} $t \gets t + s_{\text{clienteAnterior}}$ \textit{(tiempo de servicio)}.\\
% 		\hspace{2em} \textbf{fin si}\\
% 		\hspace{2em} $t \gets t + D_{\text{clienteAnterior}, \text{cliente}} / v.\text{velocidad}$ \textit{(tiempo de viaje)}.\\
% 		\hspace{2em} \textbf{si} $t < e_{\text{cliente}}$ \textbf{entonces}\\
% 		\hspace{3em} $t \gets e_{\text{cliente}}$ \textit{(esperar hasta ventana inicial)}.\\
% 		\hspace{2em} \textbf{fin si}\\
% 		\hspace{1em} \textbf{si no} \textit{(primer cliente desde depósito)}\\
% 		\hspace{2em} \textbf{si} cliente $\neq 0$ \textbf{entonces}\\
% 		\hspace{3em} $t \gets D_{0, \text{cliente}} / v.\text{velocidad}$.\\
% 		\hspace{3em} \textbf{si} $t < e_{\text{cliente}}$ \textbf{entonces}\\
% 		\hspace{4em} $t \gets e_{\text{cliente}}$.\\
% 		\hspace{3em} \textbf{fin si}\\
% 		\hspace{2em} \textbf{fin si}\\
% 		\hspace{1em} \textbf{fin si}\\

% 		\hspace{1em} \textbf{si} cliente $\neq 0$ \textbf{entonces}\\
% 		\hspace{2em} $q \gets q + d_{\text{cliente}}$ \textit{(acumular demanda)}.\\
% 		\hspace{2em} \textbf{si} $t > l_{\text{cliente}}$ \textbf{entonces}\\
% 		\hspace{3em} retornar false \textit{(violación ventana de tiempo)}.\\
% 		\hspace{2em} \textbf{fin si}\\
% 		\hspace{1em} \textbf{fin si}\\

% 		\hspace{1em} clienteAnterior $\gets$ cliente.\\
% 		\textbf{fin para}\\

% 		\textbf{Validación de capacidad:}\\
% 		\textbf{si} $q > v.Q$ \textbf{entonces}\\
% 		\hspace{1em} retornar false \textit{(violación de capacidad)}.\\
% 		\textbf{fin si}\\

% 		\textbf{Validación de retorno al depósito:}\\
% 		\textbf{si} clienteAnterior $\neq 0$ \textbf{entonces}\\
% 		\hspace{1em} $t \gets t + s_{\text{clienteAnterior}}$.\\
% 		\hspace{1em} $t \gets t + D_{\text{clienteAnterior}, 0} / v.\text{velocidad}$.\\
% 		\hspace{1em} \textbf{si} $t > l_0$ \textbf{entonces}\\
% 		\hspace{2em} retornar false \textit{(no puede regresar a tiempo)}.\\
% 		\hspace{1em} \textbf{fin si}\\
% 		\textbf{fin si}\\

% 		retornar true.\\

% 	\end{algorithm}
% 	\caption{Algoritmo de verificación completa de restricciones para una ruta. Valida secuencialmente las ventanas de tiempo de cada cliente considerando tiempos de viaje, tiempos de servicio y posibles esperas. Además verifica que la capacidad total no exceda el límite del vehículo y que sea posible retornar al depósito dentro de su ventana de tiempo.}
% 	\label{fig:verificacion_restricciones}
% \end{figure}

El mecanismo de validación opera en tres niveles:

\begin{enumerate}
	\item \textbf{Validación de capacidad:} Después de aplicar un operador, se verifica que ninguna ruta exceda la capacidad máxima del vehículo $Q$ mediante la acumulación de demandas:
	      \begin{equation}
		      \sum_{i \in \text{ruta}} d_i \leq Q
	      \end{equation}

	\item \textbf{Validación temporal:} Se recalculan los tiempos de llegada considerando:
	      \begin{equation}
		      t_{\text{llegada}}^j = t_{\text{salida}}^i + \frac{d_{ij}}{v} + s_i
	      \end{equation}
	      donde $t_{\text{inicio}}^j = \max(t_{\text{llegada}}^j, e_j)$ y se verifica que $t_{\text{inicio}}^j \leq l_j$ para todo cliente $j$.

	\item \textbf{Validación de retorno:} Se asegura que el vehículo pueda regresar al depósito dentro de su ventana de tiempo:
	      \begin{equation}
		      t_{\text{último}} + s_{\text{último}} + \frac{d_{\text{último},0}}{v} \leq l_0
	      \end{equation}
\end{enumerate}

\paragraph{Limpieza de vehículos vacíos:}

Los operadores inter-ruta pueden dejar vehículos sin clientes. El algoritmo \ref{fig:limpieza_vehiculos} describe el proceso de eliminación de vehículos vacíos.

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{Eliminación de Vehículos Vacíos}
		\label{alg:limpieza_vehiculos}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}

		\KwIn{Flota de vehículos}
		\KwOut{Número de vehículos activos}

		vehiculos\_activos $\gets 0$.\\
		vehiculo\_actual $\gets$ flota.cabeza.\\

		\textbf{mientras} vehiculo\_actual $\neq$ NULL \textbf{hacer}\\
		\hspace{1em} siguiente $\gets$ vehiculo\_actual.siguiente.\\

		\hspace{1em} \textbf{si} vehiculo\_actual.clientes\_contados $= 0$ \textbf{entonces}\\
		\hspace{2em} \textit{// Vehículo vacío, eliminar de la flota}\\
		\hspace{2em} \textbf{si} vehiculo\_actual.anterior $\neq$ NULL \textbf{entonces}\\
		\hspace{3em} vehiculo\_actual.anterior.siguiente $\gets$ siguiente.\\
		\hspace{2em} \textbf{si no}\\
		\hspace{3em} flota.cabeza $\gets$ siguiente.\\
		\hspace{2em} \textbf{fin si}\\

		\hspace{2em} \textbf{si} siguiente $\neq$ NULL \textbf{entonces}\\
		\hspace{3em} siguiente.anterior $\gets$ vehiculo\_actual.anterior.\\
		\hspace{2em} \textbf{si no}\\
		\hspace{3em} flota.cola $\gets$ vehiculo\_actual.anterior.\\
		\hspace{2em} \textbf{fin si}\\

		\hspace{2em} Liberar memoria de vehiculo\_actual.\\
		\hspace{1em} \textbf{si no}\\
		\hspace{2em} vehiculos\_activos $\gets$ vehiculos\_activos $+ 1$.\\
		\hspace{1em} \textbf{fin si}\\

		\hspace{1em} vehiculo\_actual $\gets$ siguiente.\\
		\textbf{fin mientras}\\

		retornar vehiculos\_activos.\\

	\end{algorithm}
	\caption{Proceso de limpieza de vehículos vacíos de la flota. Este procedimiento se ejecuta después de aplicar operadores inter-ruta que pueden transferir todos los clientes de un vehículo, periódicamente cada 20 iteraciones, y al finalizar el algoritmo SA para asegurar una solución compacta.}
	\label{fig:limpieza_vehiculos}
\end{figure}

La limpieza de vehículos se realiza:
\begin{itemize}
	\item Después de operadores swap\_inter, reinserción, cross-exchange y relocate-chain
	\item Periódicamente cada 20 iteraciones
	\item Al finalizar el algoritmo
\end{itemize}

Cuando se eliminan vehículos, se re-evalúa la función objetivo completa mediante el algoritmo \ref{fig:evaluacion_fitness_sa}.

\begin{figure}[H]
	\centering
	\begin{algorithm}[H]
		\caption{Evaluación de Fitness para SA}
		\label{alg:evaluacion_fitness_sa}
		\SetAlgoLined
		\SetAlFnt{\footnotesize}

		\KwIn{Solución (hormiga), matriz de distancias $D$}
		\KwOut{Fitness global actualizado}

		hormiga.fitness\_global $\gets 0$.\\
		vehiculo\_actual $\gets$ hormiga.flota.cabeza.\\

		\textbf{mientras} vehiculo\_actual $\neq$ NULL \textbf{hacer}\\
		\hspace{1em} fitness\_vehiculo $\gets 0$.\\
		\hspace{1em} nodo\_actual $\gets$ vehiculo\_actual.ruta.cabeza.\\

		\hspace{1em} \textbf{mientras} nodo\_actual.siguiente $\neq$ NULL \textbf{hacer}\\
		\hspace{2em} $i \gets$ nodo\_actual.cliente.\\
		\hspace{2em} $j \gets$ nodo\_actual.siguiente.cliente.\\
		\hspace{2em} fitness\_vehiculo $\gets$ fitness\_vehiculo $+ D_{ij}$.\\
		\hspace{2em} nodo\_actual $\gets$ nodo\_actual.siguiente.\\
		\hspace{1em} \textbf{fin mientras}\\

		\hspace{1em} vehiculo\_actual.fitness\_vehiculo $\gets$ fitness\_vehiculo.\\
		\hspace{1em} hormiga.fitness\_global $\gets$ hormiga.fitness\_global $+$ fitness\_vehiculo.\\
		\hspace{1em} vehiculo\_actual $\gets$ vehiculo\_actual.siguiente.\\
		\textbf{fin mientras}\\

		retornar hormiga.fitness\_global.\\

	\end{algorithm}
	\caption{Evaluación de la función objetivo para una solución completa. Recorre todos los vehículos de la flota y suma las distancias entre clientes consecutivos en cada ruta, incluyendo los trayectos desde y hacia el depósito.}
	\label{fig:evaluacion_fitness_sa}
\end{figure}


\subsubsection{Algoritmo principal de Recocido Simulado}

El algoritmo \ref{fig:algoritmo_sa_principal} presenta la estructura completa del proceso de refinamiento mediante SA.

% \begin{figure}[H]
% 	\centering
% 	\begin{algorithm}[H]
% 		\caption{Recocido Simulado para Refinamiento de Rutas VRP-TW}
% 		\label{alg:sa_vrptw}
% 		\SetAlgoLined
% 		\SetAlFnt{\footnotesize}

% 		\KwIn{Solución inicial $s_0$ (de ACO), $T_0$, $T_f$, $\alpha_{\text{cool}}$, $n_{\text{iter}}$}
% 		\KwOut{Solución refinada $s^*$}

% 		\textbf{Inicialización:}\\
% 		$s_{\text{vecina}} \gets$ copiar($s_0$).\\
% 		$s_{\text{actual}} \gets$ copiar($s_0$).\\
% 		$s^* \gets$ copiar($s_0$).\\
% 		$T \gets T_0$.\\

% 		\textbf{Ciclo de enfriamiento:}\\
% 		\textbf{mientras} $T > T_f$ y $T > 10^{-10}$ \textbf{hacer}\\
% 		\hspace{1em} \textbf{para} $iter=1$ \textbf{hasta} $n_{\text{iter}}$ \textbf{hacer}\\
% 		\hspace{2em} Liberar($s_{\text{vecina}}.$flota).\\
% 		\hspace{2em} $s_{\text{vecina}} \gets$ copiar($s_{\text{actual}}$).\\

% 		\hspace{2em} \textit{// Selección adaptativa de operador}\\
% 		\hspace{2em} $r \gets$ aleatorio$[0,1]$.\\
% 		\hspace{2em} operador $\gets$ SeleccionarOperador($r$, instancia.tamaño, $s_{\text{vecina}}.$vehículos).\\
% 		\hspace{2em} aceptado $\gets$ AplicarOperador(operador, $s_{\text{vecina}}$).\\

% 		\hspace{2em} \textbf{si} no aceptado \textbf{entonces} continuar.\\

% 		\hspace{2em} \textit{// Limpieza de vehículos vacíos (condicional)}\\
% 		\hspace{2em} \textbf{si} operador $\in \{$swap\_inter, reinserción, cross-exchange, relocate-chain$\}$ \textbf{entonces}\\
% 		\hspace{3em} $v_{\text{antes}} \gets s_{\text{vecina}}.$vehiculos\_necesarios.\\
% 		\hspace{3em} $s_{\text{vecina}}.$vehiculos\_necesarios $\gets$ EliminarVehiculosVacios($s_{\text{vecina}}.$flota).\\
% 		\hspace{3em} \textbf{si} $v_{\text{antes}} \neq s_{\text{vecina}}.$vehiculos\_necesarios \textbf{entonces}\\
% 		\hspace{4em} EvaluarFitness($s_{\text{vecina}}$).\\
% 		\hspace{3em} \textbf{fin si}\\
% 		\hspace{2em} \textbf{fin si}\\

% 		\hspace{2em} \textit{// Limpieza periódica}\\
% 		\hspace{2em} \textbf{si} $iter \mod 20 = 0$ \textbf{entonces}\\
% 		\hspace{3em} EliminarVehiculosVacios($s_{\text{vecina}}.$flota).\\
% 		\hspace{2em} \textbf{fin si}\\

% 		\hspace{2em} \textit{// Evaluación de fitness}\\
% 		\hspace{2em} EvaluarFitness($s_{\text{vecina}}$).\\
% 		\hspace{2em} $\Delta f \gets s_{\text{vecina}}.$fitness $- s_{\text{actual}}.$fitness.\\

% 		\hspace{2em} \textit{// Criterio de aceptación de Metropolis}\\
% 		\hspace{2em} aceptar $\gets$ false.\\
% 		\hspace{2em} \textbf{si} $\Delta f < -10^{-6}$ \textbf{entonces}\\
% 		\hspace{3em} aceptar $\gets$ true \textit{(mejora)}.\\
% 		\hspace{2em} \textbf{si no, si} $\Delta f > 10^{-6}$ y $T > 10^{-10}$ \textbf{entonces}\\
% 		\hspace{3em} $p \gets e^{-\Delta f / T}$.\\
% 		\hspace{3em} \textbf{si} aleatorio$[0,1] < p$ \textbf{entonces}\\
% 		\hspace{4em} aceptar $\gets$ true \textit{(aceptar empeoramiento)}.\\
% 		\hspace{3em} \textbf{fin si}\\
% 		\hspace{2em} \textbf{fin si}\\

% 		\hspace{2em} \textit{// Actualización de soluciones}\\
% 		\hspace{2em} \textbf{si} aceptar \textbf{entonces}\\
% 		\hspace{3em} Liberar($s_{\text{actual}}.$flota).\\
% 		\hspace{3em} $s_{\text{actual}} \gets$ copiar($s_{\text{vecina}}$).\\

% 		\hspace{3em} \textbf{si} $s_{\text{vecina}}.$fitness $< s^*.$fitness $- 10^{-6}$ \textbf{entonces}\\
% 		\hspace{4em} Liberar($s^*.$flota).\\
% 		\hspace{4em} $s^* \gets$ copiar($s_{\text{vecina}}$).\\
% 		\hspace{3em} \textbf{fin si}\\
% 		\hspace{2em} \textbf{fin si}\\

% 		\hspace{1em} \textbf{fin para}\\

% 		\hspace{1em} \textit{// Enfriamiento geométrico}\\
% 		\hspace{1em} $T \gets \alpha_{\text{cool}} \cdot T$.\\

% 		\hspace{1em} \textbf{si} $T < 10^{-10}$ \textbf{entonces} romper.\\
% 		\textbf{fin mientras}\\

% 		\textit{// Limpieza final}\\
% 		\textbf{si} $s^*.$vehiculos\_necesarios $> 1$ \textbf{entonces}\\
% 		\hspace{1em} $v_{\text{antes}} \gets s^*.$vehiculos\_necesarios.\\
% 		\hspace{1em} $s^*.$vehiculos\_necesarios $\gets$ EliminarVehiculosVacios($s^*.$flota).\\
% 		\hspace{1em} \textbf{si} $v_{\text{antes}} \neq s^*.$vehiculos\_necesarios \textbf{entonces}\\
% 		\hspace{2em} EvaluarFitness($s^*$).\\
% 		\hspace{1em} \textbf{fin si}\\
% 		\textbf{fin si}\\

% 		Liberar memoria temporal.\\
% 		retornar $s^*$.\\

% 	\end{algorithm}
% 	\caption{Algoritmo completo de Recocido Simulado para refinamiento de soluciones VRP-TW. El proceso incluye selección adaptativa de operadores según características de la instancia, criterio de aceptación de Metropolis con tolerancia numérica, limpieza condicional y periódica de vehículos vacíos, y gestión explícita de memoria. La temperatura se reduce geométricamente hasta alcanzar el umbral final, con protección contra valores extremadamente bajos.}
% 	\label{fig:algoritmo_sa_principal}
% \end{figure}

\chapter{Resultados}
\label{cap:resultados}

\chapter{Conclusiones}
\label{cap:conclusiones}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REFERENCIAS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter


\bibliographystyle{plain}
\bibliography{referencias}



\end{document}