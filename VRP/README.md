# üöö "Resoluci√≥n del Problema de Ruteo de Veh√≠culos (VRP) Metaheur√≠stica H√≠brida ACO-SA con Calibraci√≥n de Par√°metros por Evoluci√≥n Diferencial"


Este proyecto implementa una soluci√≥n h√≠brida para el Problema de Ruteo de Veh√≠culos (VRP), combinando el algoritmo de Optimizaci√≥n por Colonias de Hormigas (**ACO**) con Recocido Simulado (**SA**) como refinador local, y ajustando autom√°ticamente sus par√°metros mediante un Algoritmo Evolutivo Diferencial (**DE**).

## üß© ¬øQu√© es el VRP?

El Problema de Ruteo de Veh√≠culos (VRP, por sus siglas en ingl√©s *Vehicle Routing Problem*) es una extensi√≥n del cl√°sico Problema del Viajante (*TSP*), y representa uno de los desaf√≠os m√°s relevantes en log√≠stica y distribuci√≥n.

El objetivo es encontrar las rutas √≥ptimas para una flota de veh√≠culos que deben atender a un conjunto de clientes, considerando restricciones como la capacidad de carga de cada veh√≠culo y la demanda de cada cliente. La meta principal es **minimizar la distancia total recorrida**.

## üî• ¬øQu√© es el Recocido Simulado (SA)?

El Recocido Simulado (*Simulated Annealing*, SA) es una metaheur√≠stica inspirada en el proceso metal√∫rgico de recocido, donde un metal se calienta y luego se enfr√≠a de forma controlada para modificar sus propiedades f√≠sicas.

En optimizaci√≥n:

- Inicialmente, **acepta soluciones peores con alta probabilidad** (cuando la temperatura es alta).
- Gradualmente, **se vuelve m√°s selectivo** a medida que la temperatura disminuye (*enfriamiento*).
- Este enfoque permite escapar de √≥ptimos locales y explorar m√°s ampliamente el espacio de soluciones.

üîß En nuestro sistema, **SA toma las rutas generadas por ACO y las refina** mediante peque√±as modificaciones, aceptando temporalmente algunas soluciones sub√≥ptimas para potencialmente encontrar mejores soluciones globales.

---

## üêú ¬øQu√© es ACO (Ant Colony Optimization)?

ACO (*Ant Colony Optimization*) es una metaheur√≠stica inspirada en el comportamiento colectivo de las colonias de hormigas.

En la naturaleza, las hormigas encuentran caminos cortos entre su nido y las fuentes de alimento dejando feromonas en el trayecto. Cuanto mejor es el camino (m√°s corto), m√°s feromonas se acumulan, lo que aumenta la probabilidad de que otras hormigas lo sigan, reforzando as√≠ la soluci√≥n.

En el VRP, simulamos este comportamiento:

- Cada *hormiga* construye una soluci√≥n recorriendo los clientes.
- Las decisiones se toman en funci√≥n de:
  - **Cantidad de feromona** (conocimiento aprendido).
  - **Visibilidad** (inverso de la distancia entre nodos).
- Despu√©s de cada iteraci√≥n, se actualizan las feromonas favoreciendo los caminos m√°s prometedores.
- Se respetan las **restricciones de capacidad** de cada veh√≠culo.

---

## üß¨ ¬øQu√© es el Algoritmo Evolutivo Diferencial (DE)?

DE es una t√©cnica de optimizaci√≥n basada en poblaciones, ideal para problemas de par√°metros continuos y para el ajuste autom√°tico de hiperpar√°metros.

üìå Se basa en tres operadores clave:

- **Mutaci√≥n**: Combinaci√≥n de soluciones existentes para generar un vector perturbado.
- **Cruzamiento (recombinaci√≥n)**: Mezcla del individuo mutado con el original.
- **Selecci√≥n**: Se elige entre el original y el mutado, conservando el que tenga mejor desempe√±o.

En este proyecto, **DE ajusta autom√°ticamente los par√°metros de ACO** (como Œ±, Œ≤, œÅ, n√∫mero de hormigas, etc.) para minimizar la distancia total recorrida por los veh√≠culos.

## üß† ¬øC√≥mo se resolvi√≥ el VRP?

El enfoque fue **h√≠brido**, utilizando tres algoritmos colaborativos:

- **ACO** construye rutas factibles para una flota de veh√≠culos.
- **SA** refina las rutas generadas por ACO.
- **DE** ajusta autom√°ticamente los par√°metros de ambos algoritmos para mejorar el rendimiento global.

---

## ‚öôÔ∏è Rango de Par√°metros Adaptativos seg√∫n el Tama√±o del Problema

Para lograr una **mejor calibraci√≥n** de los algoritmos ACO (Ant Colony Optimization) y SA (Simulated Annealing), se definieron **rangos de par√°metros adaptativos** en funci√≥n del n√∫mero de clientes en la instancia del VRP.

Esto permite que los algoritmos se ajusten de forma din√°mica, dependiendo de la **complejidad del problema** (tama√±o de la instancia).

---

### üî¢ Tama√±os de instancia considerados

| Tama√±o del problema | N√∫mero de clientes (`vrp->num_clientes`) |
|---------------------|-------------------------------------------|
| **Peque√±a**         | `‚â§ 25`                                    |
| **Mediana**         | `> 25 y ‚â§ 51`                              |
| **Grande**          | `> 51 y ‚â§ 101`                             |

---

### üìê Rangos de Par√°metros por Tama√±o

#### üî∏ Instancia Peque√±a (`‚â§ 25 clientes`)

| Par√°metro                 | M√≠nimo | M√°ximo |
|---------------------------|--------|--------|
| `alpha`                   | 0.8    | 2.5    |
| `beta`                    | 2.5    | 6.0    |
| `rho`                     | 0.1    | 0.5    |
| `n√∫mero de hormigas`      | 10     | 30     |
| `iteraciones ACO`         | 50     | 200    |
| `temperatura inicial`     | 200.0  | 400.0  |
| `temperatura final`       | 0.01   | 0.1    |
| `factor de enfriamiento`  | 0.95   | 0.98   |
| `factor de control`       | 0.5    | 0.9    |
| `iteraciones SA`          | 30     | 50     |

---

#### üî∏ Instancia Mediana (`26 - 51 clientes`)

| Par√°metro                 | M√≠nimo | M√°ximo |
|---------------------------|--------|--------|
| `alpha`                   | 0.8    | 2.5    |
| `beta`                    | 2.5    | 6.0    |
| `rho`                     | 0.1    | 0.5    |
| `n√∫mero de hormigas`      | 20     | 40     |
| `iteraciones ACO`         | 50     | 200    |
| `temperatura inicial`     | 400.0  | 600.0  |
| `temperatura final`       | 0.01   | 0.1    |
| `factor de enfriamiento`  | 0.95   | 0.98   |
| `factor de control`       | 0.5    | 0.9    |
| `iteraciones SA`          | 50     | 80     |

---

#### üî∏ Instancia Grande (`52 - 101 clientes`)

| Par√°metro                 | M√≠nimo | M√°ximo |
|---------------------------|--------|--------|
| `alpha`                   | 0.8    | 2.0    |
| `beta`                    | 3.0    | 5.0    |
| `rho`                     | 0.1    | 0.3    |
| `n√∫mero de hormigas`      | 40     | 100    |
| `iteraciones ACO`         | 50     | 250    |
| `temperatura inicial`     | 600.0  | 1000.0 |
| `temperatura final`       | 0.01   | 0.1    |
| `factor de enfriamiento`  | 0.98   | 0.995  |
| `factor de control`       | 0.5    | 0.9    |
| `iteraciones SA`          | 80     | 100    |

---

### üß† ¬øPor qu√© definir rangos diferentes?

Esto permite que el algoritmo DE explore soluciones **m√°s ajustadas al tama√±o del problema**, evitando usar configuraciones demasiado peque√±as para instancias grandes, o demasiado costosas para instancias peque√±as. As√≠ se logra un **balance entre calidad de la soluci√≥n y tiempo de c√≥mputo**.

## üîÅ Proceso de Optimizaci√≥n H√≠brida (DE + ACO + SA) para VRP

1. **Inicializaci√≥n con DE**:  
   Se genera aleatoriamente una poblaci√≥n inicial de posibles soluciones, donde cada individuo representa un conjunto de par√°metros para el algoritmo **ACO** (por ejemplo: Œ±, Œ≤, œÅ, n√∫mero de hormigas, n√∫mero de iteraciones, etc.).

2. **Evaluaci√≥n de Individuos**:  
   Cada conjunto de par√°metros se eval√∫a ejecutando el algoritmo **ACO** para resolver el **VRP**, construyendo rutas factibles que respetan la capacidad de los veh√≠culos.

3. **Optimizaci√≥n Local con SA**:  
   En algunos casos, se aplica **Recocido Simulado (SA)** como optimizador local para refinar las rutas generadas por **ACO**, mejorando la asignaci√≥n de clientes y reduciendo la distancia total.

4. **C√°lculo del Fitness**:  
   Se calcula la **distancia total recorrida por todos los veh√≠culos**. Este valor se utiliza como el **fitness** del individuo, penalizando soluciones que excedan la capacidad o que tengan veh√≠culos mal distribuidos.

5. **Evoluci√≥n con DE**:  
   El algoritmo **DE** utiliza los valores de fitness para evolucionar la poblaci√≥n, generando nuevos conjuntos de par√°metros con el objetivo de **minimizar la distancia total de la soluci√≥n del VRP**.

6. **Criterio de Paro**:  
   El proceso se repite durante un n√∫mero m√°ximo de generaciones o hasta que la mejora entre generaciones sea m√≠nima.

---

Este proceso permite **optimizar autom√°ticamente** el rendimiento del algoritmo ACO (y SA), **evitando el ajuste manual** de par√°metros y encontrando de manera m√°s eficiente soluciones de alta calidad para el **Problema de Ruteo de Veh√≠culos (VRP)**.

## üöõ Gesti√≥n de Veh√≠culos y Capacidad en el VRP

A diferencia del TSP, el VRP introduce restricciones adicionales que hacen m√°s compleja la construcci√≥n de rutas:

- **Capacidad de los veh√≠culos**: Cada veh√≠culo tiene una capacidad m√°xima que no puede ser superada.
- **Demanda de los clientes**: Cada cliente requiere una cantidad espec√≠fica de producto.
- **Gesti√≥n secuencial de veh√≠culos**: Al agotarse la capacidad de un veh√≠culo, se selecciona el siguiente disponible de manera **greedy**.

El algoritmo construye rutas de la siguiente forma:

1. **Inicio en el dep√≥sito**: Cada veh√≠culo parte desde el dep√≥sito.
2. **Selecci√≥n del siguiente cliente**: Basada en una combinaci√≥n de **feromonas** (experiencia acumulada) y **visibilidad** (inverso de la distancia).
3. **Verificaci√≥n de capacidad**: Se comprueba si el veh√≠culo puede atender al cliente sin exceder su capacidad.
4. **Cambio de veh√≠culo**: Si el cliente no puede ser atendido, el veh√≠culo regresa al dep√≥sito y se asigna el siguiente veh√≠culo disponible.
5. **Cobertura total**: El proceso contin√∫a hasta que todos los clientes han sido asignados a una ruta factible.

Este enfoque garantiza que todas las restricciones del problema sean respetadas, generando soluciones viables y eficientes para el VRP.

## üéØ Resultados Esperados

El objetivo principal de este proyecto es encontrar la mejor soluci√≥n al **Problema de Ruteo de Veh√≠culos (VRP)** utilizando un enfoque h√≠brido con los algoritmos **ACO**, **SA** y **DE**.  
El algoritmo **DE** se encarga de optimizar autom√°ticamente los par√°metros de ACO y SA, adapt√°ndose al tama√±o y complejidad de la instancia.

---

### üîç ¬øQu√© se espera como salida?

1. **Conjunto de rutas optimizadas**  
   Una soluci√≥n factible donde todos los clientes son atendidos, respetando las restricciones de capacidad, y con una distancia total m√≠nima.

2. **Distancia total recorrida**  
   Suma de las distancias de todas las rutas generadas por los veh√≠culos.

3. **Tiempo de ejecuci√≥n total**  
   Tiempo que toma ejecutar el proceso completo de optimizaci√≥n, incluyendo la calibraci√≥n de par√°metros y construcci√≥n/refinamiento de rutas.

4. **Par√°metros √≥ptimos encontrados**  
   Valores de Œ±, Œ≤, œÅ, temperatura, n√∫mero de hormigas, iteraciones, etc., que generaron la mejor soluci√≥n en la instancia evaluada.

### üì¶ Resultados Generados

3. **Archivo JSON**

   - Se genera un archivo `.json` que contiene todos los **par√°metros optimizados autom√°ticamente** durante la ejecuci√≥n, incluyendo:
     - Nombre del archivo de entrada
     - Tiempo de ejecuci√≥n en minutos
     - Tama√±o de poblaci√≥n y n√∫mero de generaciones del DE
     - Par√°metros de ACO (`Œ±`, `Œ≤`, `œÅ`, n√∫mero de hormigas, iteraciones ACO)
     - Par√°metros de SA (temperatura inicial, final, factor de enfriamiento, factor de control, iteraciones SA)
     - Valor de fitness de la soluci√≥n (distancia total recorrida)
     - Conjunto de rutas generadas (lista de clientes visitados por cada veh√≠culo)

4. **Imagen simulada**

   - Se genera una imagen est√°tica (`.png`) que representa visualmente el **conjunto de rutas** recorridas por los veh√≠culos, partiendo y regresando al dep√≥sito.

   Ejemplo de visualizaci√≥n:  
   ![Imagen Ruta](Recursos_Readme/Ejemplo_png.png)

5. **GIF simulado** 

   - Se crea un **GIF animado** que simula el proceso de construcci√≥n de las rutas, mostrando c√≥mo cada veh√≠culo va atendiendo clientes, seg√∫n el proceso de decisi√≥n de la hormiga.

   Ejemplo de animaci√≥n:  
   ![Simulador Ruta](Recursos_Readme/Ejemplo_gif.gif)


### üíæ Ejemplo de archivo JSON

El archivo `JSON` generado tendr√° la siguiente estructura:
```json
{
	"Archivo":	"RC100_(25)",
	"Tiempo Ejecucion en Minutos":	2,
	"Alpha":	1.332143975506604,
	"Beta":	2.7454391065963728,
	"Rho":	0.19041168572865974,
	"Numero Hormigas":	20,
	"Numero Iteraciones ACO":	148,
	"Temperatura Inicial: ":	540.64893656906145,
	"Temperatura Final: ":	0.083569377757874028,
	"Factor de Enfriamiento: ":	0.9893298309293248,
	"Factor de Control: ":	0.532362188786437,
	"Numero Iteraciones SA: ":	50,
	"Fitness Global":	294.99443951784644,
	"flota":	[{
			"Id_vehiculo":	1,
			"Capacidad Maxima":	200,
			"Capacidad Acumulada":	180,
			"Numero Clientes":	8,
			"Fitness Vehiculo":	101.88256760196126,
			"Ruta Clientes":	[0, 24, 25, 23, 21, 18, 19, 20, 22, 0],
		}, {
			"Id_vehiculo":	2,
			"Capacidad Maxima":	200,
			"Capacidad Acumulada":	190,
			"Numero Clientes":	9,
			"Fitness Vehiculo":	97.2271627850669,
			"Ruta Clientes":	[0, 10, 11, 9, 13, 15, 16, 17, 14, 12, 0],
		}, {
			"Id_vehiculo":	3,
			"Capacidad Maxima":	200,
			"Capacidad Acumulada":	170,
			"Numero Clientes":	8,
			"Fitness Vehiculo":	95.884709130818266,
			"Ruta Clientes":	[0, 1, 3, 5, 4, 8, 7, 6, 2, 0],
		}]
}
```

## Requisitos

Para ejecutar este proyecto, aseg√∫rate de tener lo siguiente:

### üßë‚Äçüíª C Compiler

Es necesario tener un compilador de C instalado (como gcc) para compilar el c√≥digo fuente.

### Librer√≠a `cJSON`:  
  Este proyecto requiere la librer√≠a `cJSON` para trabajar con archivos JSON en C.  
  Puedes encontrarla y consultar c√≥mo instalarla en su repositorio oficial:
    
  üëâ [https://github.com/DaveGamble/cJSON](https://github.com/DaveGamble/cJSON)

### üì¶ Python

Aseg√∫rate de tener Python instalado junto con las siguientes bibliotecas:

- json
- os
- sys
- matplotlib
- numpy

## Compilaci√≥n y Ejecuci√≥n

### 1. **Compilaci√≥n**

Para compilar el proyecto, usa el siguiente comando:

```bash
make
```

Este comando compilar√° el c√≥digo en modo release por defecto (optimizado). Si prefieres compilar en modo debug para facilitar la depuraci√≥n, puedes usar:

```bash
make debug
```

### 2. Ejecutar el Programa

Una vez compilado el proyecto, puedes ejecutar el ejecutable generado (llamado main) con los siguientes par√°metros:

```bash
./main <poblacion> <generaciones> <archivo> <numero_de_clientes>
```

Ejemplo:
```bash
./main 50 100 RC100 25
```

- poblacion: el tama√±o de la poblaci√≥n para el algoritmo.
- generaciones: el n√∫mero de generaciones que el algoritmo debe ejecutar.
- archivo: el archivo de entrada.
- numero_de_clientes: el n√∫mero de clientes a considerar en el VRP.

### 3. Limpieza

Si deseas limpiar los archivos generados (archivos objeto, ejecutables, etc.), puedes usar:

```bash
make clean
```

## üìÅ Estructura del Proyecto

```bash
.
‚îú‚îÄ‚îÄ build/                     # Archivos objetos y dependencias generados por el compilador
‚îú‚îÄ‚îÄ include/                  # Archivos de cabecera (.h)
‚îÇ   ‚îú‚îÄ‚îÄ aed.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_vrp.h    
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.h
‚îÇ   ‚îú‚îÄ‚îÄ estructuras.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.h
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.h
‚îÇ   ‚îú‚îÄ‚îÄ vrp_aco.h
‚îÇ   ‚îî‚îÄ‚îÄ vrp_sa.h               
‚îú‚îÄ‚îÄ Instancias/               # Instancias CSV utilizadas en la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_25/        
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_50/
‚îÇ   ‚îî‚îÄ‚îÄ Instancias_100/
‚îú‚îÄ‚îÄ main                      # Ejecutable generado tras compilar
‚îú‚îÄ‚îÄ makefile                  # Makefile para compilar el proyecto
‚îú‚îÄ‚îÄ README.md                 # Archivo de documentaci√≥n
‚îú‚îÄ‚îÄ Resultados/               # Salidas generadas por la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_25/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_50/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îî‚îÄ‚îÄ Resultados_100/
‚îÇ       ‚îú‚îÄ‚îÄ Gifs/
‚îÇ       ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ       ‚îî‚îÄ‚îÄ Json/
‚îú‚îÄ‚îÄ src/                      # C√≥digo fuente del proyecto en C y Python
‚îÇ   ‚îú‚îÄ‚îÄ aed.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_vrp.c  
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.c
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.c
‚îÇ   ‚îú‚îÄ‚îÄ vrp_aco.c
‚îÇ   ‚îú‚îÄ‚îÄ vrp_sa.c              
‚îÇ   ‚îî‚îÄ‚îÄ Simulador_VRP/        # Modificado para VRP
‚îÇ       ‚îî‚îÄ‚îÄ simulador_vrp.py
‚îî‚îÄ‚îÄ VRP_Solomon/              # Instancias del benchmark Solomon
    ‚îú‚îÄ‚îÄ VRP_Solomon_25/
    ‚îÇ   ‚îú‚îÄ‚îÄ C100_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C200_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R100_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R200_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC100_(25).txt
    ‚îÇ   ‚îî‚îÄ‚îÄ RC200_(25).txt
    ‚îú‚îÄ‚îÄ VRP_Solomon_50/
    ‚îÇ   ‚îú‚îÄ‚îÄ C100_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C200_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R100_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R200_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC100_(50).txt
    ‚îÇ   ‚îî‚îÄ‚îÄ RC200_(50).txt
    ‚îî‚îÄ‚îÄ VRP_Solomon_100/
        ‚îú‚îÄ‚îÄ C100_(100).txt
        ‚îú‚îÄ‚îÄ C200_(100).txt
        ‚îú‚îÄ‚îÄ R100_(100).txt
        ‚îú‚îÄ‚îÄ R200_(100).txt
        ‚îî‚îÄ‚îÄ RC100_(100).txt

```

## ‚úÖ Conclusi√≥n
Este proyecto present√≥ una soluci√≥n h√≠brida al Problema de Ruteo de Veh√≠culos (VRP), integrando las fortalezas de tres algoritmos metaheur√≠sticos: ACO para la construcci√≥n de rutas, SA como optimizador local y DE como calibrador autom√°tico de par√°metros. La combinaci√≥n permiti√≥ generar rutas eficientes que respetan las restricciones del problema, al mismo tiempo que se optimizaban autom√°ticamente los hiperpar√°metros involucrados.

Gracias al uso de rangos adaptativos de par√°metros seg√∫n el tama√±o del problema, se logr√≥ un equilibrio entre calidad de la soluci√≥n y eficiencia computacional, permitiendo que el sistema sea escalable a distintas instancias del VRP.

Los resultados obtenidos evidencian que la integraci√≥n de ACO con SA mejora la calidad de las rutas mediante refinamiento local, mientras que DE contribuye significativamente a la exploraci√≥n del espacio de configuraciones √≥ptimas, reduciendo la necesidad de ajuste manual.

En conjunto, este enfoque demostr√≥ ser una alternativa robusta y flexible para abordar problemas de ruteo complejos en log√≠stica, con potencial de ser aplicado o extendido a otras variantes del VRP o a escenarios reales.

## üöÄ Trabajo futuro

Como l√≠nea futura de trabajo, se propone la integraci√≥n de otros enfoques metaheur√≠sticos h√≠bridos que puedan mejorar la calidad de las soluciones encontradas y reducir el tiempo de c√≥mputo. Tambi√©n ser√≠a interesante evaluar el rendimiento del algoritmo propuesto con diferentes tipos de instancias del problema, incluyendo aquellas con restricciones m√°s complejas como ventanas de tiempo o m√∫ltiples dep√≥sitos.

Adem√°s, se podr√≠a explorar la paralelizaci√≥n del algoritmo utilizando t√©cnicas de programaci√≥n concurrente o programaci√≥n paralela, con el fin de acelerar el proceso de optimizaci√≥n en instancias de mayor tama√±o.

## ‚úÖ Consideraciones finales

Este trabajo busca contribuir al estudio y soluci√≥n del problema VRP mediante la implementaci√≥n de algoritmos bioinspirados. La principal diferencia respecto a la versi√≥n TSP es la incorporaci√≥n de restricciones de capacidad y la selecci√≥n greedy de veh√≠culos. Se invita a la comunidad a explorar, reutilizar y mejorar el c√≥digo seg√∫n sus necesidades.

## üë• Contribuciones

- üßë‚Äçüè´ **Dr. Edwin Montes Orozco**  
  Director de PT y responsable del acompa√±amiento acad√©mico durante el desarrollo del proyecto.

- üë®‚Äçüíª **Alejandro Mart√≠nez Guzm√°n**  
  Autor del proyecto. Encargado del dise√±o, implementaci√≥n y documentaci√≥n del sistema de optimizaci√≥n.

- üß™ **Jaime L√≥pez Lara**  
  Ayudante en la ejecuci√≥n del c√≥digo y recolecci√≥n de resultados.

## üìù Licencia

Este proyecto est√° licenciado bajo los t√©rminos de la licencia MIT.  
Consulta el archivo [LICENSE](./LICENSE) para m√°s detalles.