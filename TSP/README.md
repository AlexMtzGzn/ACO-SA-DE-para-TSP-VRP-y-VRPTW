# üöö "Optimizaci√≥n del Problema del Agente Viajero (TSP) mediante una Metaheur√≠stica H√≠brida ACO-SA con Calibraci√≥n de Par√°metros por Evoluci√≥n Diferencial"

Este proyecto implementa una soluci√≥n h√≠brida para el Problema del Agente Viajero (TSP), utilizando el algoritmo Ant Colony Optimization (ACO) para generar rutas iniciales, el Recocido Simulado (SA) para refinarlas, y todo el proceso optimizado autom√°ticamente mediante el Algoritmo Evolutivo Diferencial (DE).

## üß© ¬øQu√© es el TSP?

El Problema del Agente Viajero (TSP, por sus siglas en ingl√©s "Traveling Salesman Problem") es uno de los problemas cl√°sicos m√°s conocidos en optimizaci√≥n combinatoria.

Consiste en encontrar la ruta m√°s corta posible que permita a un viajero visitar una serie de ciudades o clientes **exactamente una vez** y regresar al punto de partida.

## üêú ¬øQu√© es ACO (Ant Colony Optimization)?

ACO (Ant Colony Optimization) es una metaheur√≠stica inspirada en el comportamiento colectivo de las colonias de hormigas.

En la naturaleza, las hormigas encuentran caminos cortos entre su nido y las fuentes de comida dejando feromonas. Cuanto mejor sea el camino (m√°s corto), m√°s feromonas se acumulan, y m√°s probable es que otras hormigas lo sigan, reforzando as√≠ la soluci√≥n.

En el TSP, simulamos este comportamiento:

- Cada "hormiga" construye una soluci√≥n recorriendo ciudades o clientes.
- Las decisiones se toman con base en:
  - **Cantidad de feromona** (lo aprendido)
  - **Visibilidad** (inverso de la distancia)
- Despu√©s de cada iteraci√≥n, se actualizan las feromonas, favoreciendo los caminos m√°s cortos.

## üî• ¬øQu√© es el Recocido Simulado (SA)?

El Recocido Simulado (Simulated Annealing, SA) es una metaheur√≠stica inspirada en el proceso metal√∫rgico de recocido, donde un metal se calienta y luego se enfr√≠a controladamente para modificar sus propiedades f√≠sicas.
En optimizaci√≥n:

- Inicialmente acepta soluciones peores con alta probabilidad (temperatura alta)
- Gradualmente se vuelve m√°s selectivo (enfriamiento)

Este enfoque permite escapar de √≥ptimos locales y explorar m√°s ampliamente el espacio de soluciones.

En nuestro sistema, SA toma las rutas generadas por ACO y las refina mediante peque√±as modificaciones, aceptando algunas soluciones sub√≥ptimas temporalmente para potencialmente encontrar mejores soluciones globales.

## üîÑ Movimientos de Vecindad del Recocido Simulado (SA)

Durante la optimizaci√≥n local con SA, se generan **soluciones vecinas** a partir de la soluci√≥n actual mediante uno de los siguientes tres movimientos aleatorios:

1. **Inversi√≥n de un segmento de ruta:**  
   Se selecciona una ruta y se invierte el orden de visita de un segmento entre dos clientes. Este cambio puede reducir la distancia total si existen trayectos cruzados o ineficientes.

2. **Intercambio de dos clientes:**  
   Se eligen dos clientes (dentro de una misma ruta o entre rutas diferentes) y se intercambian sus posiciones. Esto puede modificar significativamente la estructura del recorrido.

3. **Reubicaci√≥n de un cliente dentro de una ruta:**  
   Se toma un cliente y se lo mueve a otra posici√≥n dentro de la misma ruta. Es √∫til para ajustes finos sin alterar mucho la composici√≥n de la ruta.

La elecci√≥n del movimiento se realiza aleatoriamente con igual probabilidad, usando el siguiente criterio:

```bash
if (prob < factor / 3.0)
    aceptado = invertirSegmentoRuta(...);
else if (prob < 2.0 * factor / 3.0)
    aceptado = intercambiarClienteRuta(...);
else
    aceptado = moverClienteDentroDeRuta(...);
```

Donde prob es un n√∫mero aleatorio entre 0 y 1, y factor es calibrado por DE.

Este conjunto de movimientos permite que SA explore diversas configuraciones vecinas, ayudando a escapar de √≥ptimos locales y mejorando la calidad de las rutas generadas por ACO.

## üß¨ ¬øQu√© es el Algoritmo Evolutivo Diferencial (DE)?

DE es una t√©cnica de optimizaci√≥n basada en poblaciones. Ideal para problemas continuos y para ajustar par√°metros autom√°ticamente.

üìå Se basa en tres operadores:

Mutaci√≥n ‚Äì Combinaci√≥n de soluciones existentes.

Cruzamiento (recombinaci√≥n) ‚Äì Mezcla de individuo mutado y original.

Selecci√≥n ‚Äì Se elige el m√°s apto entre ambos.

## üß† ¬øC√≥mo se resolvi√≥ el TSP?

El enfoque fue **h√≠brido** con tres algortimos:

- **ACO** resuelve el TSP directamente.
- **SA** refina las rutas generadas por ACO.
- **DE** encuentra los mejores par√°metros para ambos algoritmos.

## ‚öôÔ∏è Rango de Par√°metros Adaptativos seg√∫n el Tama√±o del Problema

Para lograr una **mejor calibraci√≥n** de los algoritmos ACO (Ant Colony Optimization) y SA (Simulated Annealing), se definieron **rangos de par√°metros adaptativos** en funci√≥n del n√∫mero de clientes en la instancia del TSP.

Esto permite que los algoritmos se ajusten de forma din√°mica, dependiendo de la complejidad del problema (tama√±o de la instancia).

---

### üî¢ Tama√±os de instancia considerados

| Tama√±o del problema | N√∫mero de clientes (`tsp->num_clientes`) |
| ------------------- | ---------------------------------------- |
| **Peque√±a**         | `25`                                     |
| **Mediana**         | `50`                                     |
| **Grande**          | `100`                                    |

---

### üìê Rangos de Par√°metros por Tama√±o

#### üî∏ Instancia Peque√±a (`25 clientes`)

| Par√°metro                | M√≠nimo | M√°ximo |
| ------------------------ | ------ | ------ |
| `alpha`                  | 1.0    | 3.0    |
| `beta`                   | 1.0    | 3.0    |
| `rho`                    | 0.5    | 0.7    |
| `n√∫mero de hormigas`     | 10     | 25     |
| `iteraciones ACO`        | 50     | 100    |
| `temperatura inicial`    | 1000.0 | 2000.0 |
| `temperatura final`      | 0.1    | 0.5    |
| `factor de enfriamiento` | 0.99   | 0.999  |
| `factor de control`      | 0.7    | 0.5    |
| `iteraciones SA`         | 100    | 150    |

---

#### üî∏ Instancia Mediana (`50 clientes`)

| Par√°metro                | M√≠nimo | M√°ximo |
| ------------------------ | ------ | ------ |
| `alpha`                  | 2.0    | 4.0    |
| `beta`                   | 2.0    | 4.0    |
| `rho`                    | 0.4    | 0.6    |
| `n√∫mero de hormigas`     | 25     | 40     |
| `iteraciones ACO`        | 100    | 150    |
| `temperatura inicial`    | 1500.0 | 2500.0 |
| `temperatura final`      | 0.1    | 0.3    |
| `factor de control`      | 0.6    | 0.8    |
| `factor de enfriamiento` | 0.95   | 0.999  |
| `iteraciones SA`         | 150    | 200    |

---

#### üî∏ Instancia Grande (`100 clientes`)

| Par√°metro                | M√≠nimo | M√°ximo |
| ------------------------ | ------ | ------ |
| `alpha`                  | 3.0    | 5.0    |
| `beta`                   | 3.0    | 5.0    |
| `rho`                    | 0.3    | 0.5    |
| `n√∫mero de hormigas`     | 40     | 50     |
| `iteraciones ACO`        | 150    | 200    |
| `temperatura inicial`    | 2000.0 | 3000.0 |
| `temperatura final`      | 0.1    | 0.2    |
| `factor de enfriamiento` | 0.95   | 0.999  |
| `factor de control`      | 0.6    | 0.9    |
| `iteraciones SA`         | 200    | 300    |

---

### üß† ¬øPor qu√© definir rangos diferentes?

Esto permite que el algoritmo DE explore soluciones **m√°s ajustadas al tama√±o del problema**, evitando usar configuraciones demasiado peque√±as para instancias grandes, o demasiado costosas para instancias peque√±as. De esta manera se logra un **balance entre calidad de la soluci√≥n y tiempo de c√≥mputo.**

---

## üîÅ Proceso de Optimizaci√≥n H√≠brida (DE + ACO + SA) para TSP

1. **Inicializaci√≥n con DE**:  
   Se genera aleatoriamente una poblaci√≥n inicial de posibles soluciones, donde cada individuo representa un conjunto de par√°metros para el algoritmo **ACO** y **SA**.

2. **Evaluaci√≥n de Individuos**:  
   Cada conjunto de par√°metros se eval√∫a ejecutando el algoritmo **ACO** y **SA** con dichos valores.

3. **Optimizaci√≥n Local**:  
   Despu√©s de que **ACO** genera una soluci√≥n (ruta), se aplica **Recocido Simulado (SA)** como optimizador local. Este paso consiste en realizar peque√±os ajustes en la ruta generada por **ACO** para mejorar su calidad. **SA** se encarga de explorar soluciones vecinas a la actual (cercanas en el espacio de soluciones) para encontrar una mejor soluci√≥n local. Durante este proceso, **SA** acepta temporalmente soluciones peores con una probabilidad que disminuye gradualmente a medida que "enfr√≠a" su temperatura, permitiendo escapar de √≥ptimos locales.

4. **C√°lculo del Fitness**:  
   Se obtiene la **distancia total de la mejor ruta** generada por **ACO** y refinada con **SA**. Esta distancia se utiliza como el valor de fitness del individuo.

5. **Evoluci√≥n con DE**:  
   El algoritmo **DE** utiliza los valores de fitness para evolucionar la poblaci√≥n, generando nuevos conjuntos de par√°metros con el objetivo de **minimizar la distancia total**.

6. **Criterio de Paro**:  
   El proceso se repite durante un n√∫mero m√°ximo de generaciones.

---

Este proceso permite **optimizar autom√°ticamente** el rendimiento del algoritmo **ACO** y **SA**, **evitando el ajuste manual** de par√°metros y encontrando de manera m√°s eficiente soluciones de alta calidad para el **Problema del Agente Viajero (TSP)**.

## üéØ Resultados Esperados

El objetivo principal de este proyecto es encontrar la mejor ruta para el **Problema del Agente Viajero(TSP)** mediante el uso combinado del algoritmo **ACO** y el algoritmo **DE**, el cual optimiza autom√°ticamente los par√°metros del **ACO** y del **SA**.

---

### üîç ¬øQu√© se espera como salida?

1. **La mejor ruta encontrada**  
   La ruta √≥ptima, que minimiza la distancia total recorrida.

2. **Tiempo de ejecuci√≥n total**  
   El tiempo total que tom√≥ ejecutar el proceso de optimizaci√≥n y encontrar la mejor ruta.

---

### üì¶ Resultados Generados

3. **Archivo JSON**

   - Se genera un archivo `.json` que contiene todos los **par√°metros optimizados autom√°ticamente** durante la ejecuci√≥n, tales como:
     - Nombre del archivo de entrada
     - Tiempo de ejecuci√≥n en minutos
     - Poblaci√≥n y generaciones del DE
     - Par√°metros de ACO (`Œ±`, `Œ≤`, `œÅ`, n√∫mero de hormigas, iteraciones ACO)
     - Par√°metros de SA (temperatura inicial, final, factor de enfriamiento, iteraciones SA)
     - Valor de fitness de la soluci√≥n
     - Ruta generada (lista de ciudades o clientes visitados)

4. **Imagen simulada**

   - Se genera una imagen est√°tica (`.png`) que representa visualmente la **ruta generada** por el algoritmo ACO.

   Ejemplo de visualizaci√≥n:
   ![Imagen Ruta](Recursos_Readme/Ejemplo_png.png)

5. **GIF simulado**

   - Se crea un **GIF animado** que simula el proceso de construcci√≥n de la ruta, mostrando c√≥mo la mejor hormiga recorre las ciudades o clientes a lo largo del tiempo.

   Ejemplo de animaci√≥n:
   ![Simulador Ruta](Recursos_Readme/Ejemplo_gif.gif)

---

### üíæ Ejemplo de archivo JSON

El archivo `JSON` generado tendr√° una estructura como la siguiente:

```json
{
  "Archivo": "C101",
  "Tiempo Ejecucion en Minutos": 2,
  "Poblacion": 10,
  "Generaciones": 10,
  "Alpha": 2.3476589154906842,
  "Beta": 2.3577138539323181,
  "Rho": 0.2498495201812356,
  "Numero Hormigas": 35,
  "Numero Iteraciones ACO": 100,
  "Temperatura Inicial": 748.30022249291665,
  "Temperatura Final": 0.1,
  "Factor de Enfriamiento": 0.99,
  "Numero Iteraciones SA": 99,
  "Fitness Global": 132.12162500340892,
  "Ruta Clientes": [
    0, 20, 21, 22, 24, 25, 23, 13, 17, 18, 19, 15, 16, 14, 12, 11, 10, 8, 9, 6,
    4, 2, 1, 3, 5, 7, 0
  ]
}
```

## Requisitos

Para ejecutar este proyecto, aseg√∫rate de tener lo siguiente:

### üßë‚Äçüíª C Compiler

Es necesario tener un compilador de C instalado (como gcc) para compilar el c√≥digo fuente.

### Librer√≠a `cJSON`:

Este proyecto requiere la librer√≠a `cJSON` para trabajar con archivos JSON en C.  
 Puedes encontrarla y consultar c√≥mo instalarla en su repositorio oficial:

üëâ [https://github.com/DaveGamble/cJSON](https://github.com/DaveGamble/cJSON)

### üì¶ Python

Aseg√∫rate de tener Python instalado junto con las siguientes bibliotecas:

- json
- os
- sys
- matplotlib
- numpy

## Compilaci√≥n y Ejecuci√≥n

### 1. **Compilaci√≥n**

Para compilar el proyecto, usa el siguiente comando:

```bash
make
```

Este comando compilar√° el c√≥digo en modo release por defecto (optimizado). Si prefieres compilar en modo debug para facilitar la depuraci√≥n, puedes usar:

```bash
make debug
```

### 2. Ejecutar el Programa

Una vez compilado el proyecto, puedes ejecutar el ejecutable generado (llamado main) con los siguientes par√°metros:

```bash
./main <poblacion> <generaciones> <archivo> <numero_de_clientes>
```

Ejemplo:

```bash
./main 50 100 C100 25
```

- poblacion: el tama√±o de la poblaci√≥n para el algoritmo.

- generaciones: el n√∫mero de generaciones que el algoritmo debe ejecutar.

- archivo: el archivo de entrada.

- numero_de_clientes: el n√∫mero de clientes o ciudades a considerar en el TSP.

### 3. Limpieza

Si deseas limpiar los archivos generados (archivos objeto, ejecutables, etc.), puedes usar:

```bash
make clean
```

## üìÅ Estructura del Proyecto

```bash
.
‚îú‚îÄ‚îÄ build/                     # Archivos objetos y dependencias generados por el compilador
‚îú‚îÄ‚îÄ include/                  # Archivos de cabecera (.h)
‚îÇ   ‚îú‚îÄ‚îÄ aed.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.h
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_tsp.h
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.h
‚îÇ   ‚îú‚îÄ‚îÄ estructuras.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.h
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.h
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.h
‚îÇ   ‚îú‚îÄ‚îÄ tsp_sa.h
‚îÇ   ‚îî‚îÄ‚îÄ vrp_aco.h
‚îú‚îÄ‚îÄ Instancias/               # Instancias CSV utilizadas en la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_25/
‚îÇ   ‚îú‚îÄ‚îÄ Instancias_50/
‚îÇ   ‚îî‚îÄ‚îÄ Instancias_100/
‚îú‚îÄ‚îÄ main                      # Ejecutable generado tras compilar
‚îú‚îÄ‚îÄ makefile                  # Makefile para compilar el proyecto
‚îú‚îÄ‚îÄ README.md                 # Archivo de documentaci√≥n
‚îú‚îÄ‚îÄ Resultados/               # Salidas generadas por la ejecuci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_25/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îú‚îÄ‚îÄ Resultados_50/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gifs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Json/
‚îÇ   ‚îî‚îÄ‚îÄ Resultados_100/
‚îÇ       ‚îú‚îÄ‚îÄ Gifs/
‚îÇ       ‚îú‚îÄ‚îÄ Imagenes/
‚îÇ       ‚îî‚îÄ‚îÄ Json/
‚îú‚îÄ‚îÄ src/                      # C√≥digo fuente del proyecto en C y Python
‚îÇ   ‚îú‚îÄ‚îÄ aed.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_json.c
‚îÇ   ‚îú‚îÄ‚îÄ configuracion_tsp.c
‚îÇ   ‚îú‚îÄ‚îÄ control_memoria.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_flota.c
‚îÇ   ‚îú‚îÄ‚îÄ lista_ruta.c
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îú‚îÄ‚îÄ salida_datos.c
‚îÇ   ‚îú‚îÄ‚îÄ tsp_sa.c
‚îÇ   ‚îú‚îÄ‚îÄ vrp_aco.c
‚îÇ   ‚îî‚îÄ‚îÄ Simulador_TSP/
‚îÇ       ‚îî‚îÄ‚îÄ simulador_tsp.py
‚îî‚îÄ‚îÄ VRP_Solomon/              # Instancias del benchmark Solomon
    ‚îú‚îÄ‚îÄ VRP_Solomon_25/
    ‚îÇ   ‚îú‚îÄ‚îÄ C100_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C200_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R100_(25).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC100_(25).txt
    ‚îú‚îÄ‚îÄ VRP_Solomon_50/
    ‚îÇ   ‚îú‚îÄ‚îÄ C100_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ C200_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ R100_(50).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ RC100_(50).txt
    ‚îî‚îÄ‚îÄ VRP_Solomon_100/
        ‚îú‚îÄ‚îÄ C100_(100).txt
        ‚îú‚îÄ‚îÄ C200_(100).txt
        ‚îú‚îÄ‚îÄ R100_(100).txt
        ‚îî‚îÄ‚îÄ RC100_(100).txt
```

## ‚úÖ Conclusi√≥n

El desarrollo de una metaheur√≠stica h√≠brida basada en Ant Colony Optimization (ACO) y Recocido Simulado (SA), calibrada autom√°ticamente mediante un Algoritmo Evolutivo Diferencial (DE), demostr√≥ ser una estrategia efectiva para resolver el Problema del Agente Viajero (TSP).

El uso de ACO permiti√≥ generar soluciones iniciales de alta calidad inspiradas en el comportamiento de las hormigas, mientras que SA refin√≥ estas soluciones para escapar de √≥ptimos locales y explorar regiones m√°s prometedoras del espacio de b√∫squeda. La incorporaci√≥n del DE automatiz√≥ por completo el ajuste de par√°metros, adaptando la configuraci√≥n de los algoritmos en funci√≥n del tama√±o y complejidad del problema.

Gracias a este enfoque h√≠brido, se obtuvieron rutas m√°s cortas y eficientes con menor intervenci√≥n manual, haciendo el sistema escalable y vers√°til para distintas instancias del TSP. Adem√°s, el uso de rangos adaptativos por tama√±o del problema garantiz√≥ un equilibrio entre precisi√≥n y eficiencia computacional.

## üöÄ Trabajo futuro

Como l√≠nea futura de trabajo, se propone la integraci√≥n de otros enfoques metaheur√≠sticos h√≠bridos que puedan mejorar la calidad de las soluciones encontradas y reducir el tiempo de c√≥mputo. Tambi√©n ser√≠a interesante evaluar el rendimiento del algoritmo propuesto con diferentes tipos de instancias del problema.

Adem√°s, se podr√≠a explorar la paralelizaci√≥n del algoritmo utilizando t√©cnicas de programaci√≥n concurrente o programaci√≥n paralela, con el fin de acelerar el proceso de optimizaci√≥n en instancias de mayor tama√±o.

## ‚úÖ Consideraciones finales

Este trabajo busca contribuir al estudio y soluci√≥n del problema TSP mediante la implementaci√≥n de algoritmos bioinspirados. Se invita a la comunidad a explorar, reutilizar y mejorar el c√≥digo seg√∫n sus necesidades.

## üë• Contribuciones

- üßë‚Äçüè´ **Dr. Edwin Montes Orozco**  
  Director de PT y responsable del acompa√±amiento acad√©mico durante el desarrollo del proyecto.

- üë®‚Äçüíª **Alejandro Mart√≠nez Guzm√°n**  
  Autor del proyecto. Encargado del dise√±o, implementaci√≥n y documentaci√≥n del sistema de optimizaci√≥n.

- üß™ **Jaime L√≥pez Lara**  
  Ayudante en la ejecuci√≥n del c√≥digo y recolecci√≥n de resultados.

## üìù Licencia

Este proyecto est√° licenciado bajo los t√©rminos de la licencia MIT.  
Consulta el archivo [LICENSE](./LICENSE) para m√°s detalles.
